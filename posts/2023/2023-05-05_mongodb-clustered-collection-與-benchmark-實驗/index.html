<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="MongoDB 在 5.3 加入了 Clustered Collection 宣稱可以增加讀寫的效能，試著去了解背後的原理與用 benchmark 實測看看"><meta name=keywords content="MongoDB"><title>MongoDB Clustered Collection 與 Benchmark 實驗</title><link rel=canonical href=https://yuanchieh.page/posts/2023/2023-05-05-mongodb-clustered-collection-%E8%88%87-benchmark-%E5%AF%A6%E9%A9%97/><link rel=stylesheet href=/scss/style.min.ff300df33b80e2ac49809c825614392ed1c7b27591d65d3c4043602cd162e25f.css><meta property="og:title" content="MongoDB Clustered Collection 與 Benchmark 實驗"><meta property="og:description" content="MongoDB 在 5.3 加入了 Clustered Collection 宣稱可以增加讀寫的效能，試著去了解背後的原理與用 benchmark 實測看看"><meta property="og:url" content="https://yuanchieh.page/posts/2023/2023-05-05-mongodb-clustered-collection-%E8%88%87-benchmark-%E5%AF%A6%E9%A9%97/"><meta property="og:site_name" content="Yuanchieh"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:published_time" content="2023-05-05T00:21:40+00:00"><meta property="article:modified_time" content="2023-05-05T00:21:40+00:00"><meta name=twitter:title content="MongoDB Clustered Collection 與 Benchmark 實驗"><meta name=twitter:description content="MongoDB 在 5.3 加入了 Clustered Collection 宣稱可以增加讀寫的效能，試著去了解背後的原理與用 benchmark 實測看看"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-82837682-4","auto"),ga("send","pageview"))</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-82837682-4"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-82837682-4")</script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src="https://avatars0.githubusercontent.com/u/6858460?s=460&amp;v=4" width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Yuanchieh</a></h1><h2 class=site-description>生命是長期而持續的累積</h2></div></header><ol class=social-menu><li><a href=https://github.com/sj82516 target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#mongodb-storage-engine-演進>MongoDB Storage Engine 演進</a><ol><li><a href=#mmapv1>MMAPv1</a></li><li><a href=#wiredtiger>WiredTiger</a></li><li><a href=#wiredtiger-clustered-collection-原理>WiredTiger Clustered Collection 原理</a></li></ol></li><li><a href=#benchmark>Benchmark</a><ol><li><a href=#insert-比較>Insert 比較</a></li><li><a href=#search-比較>Search 比較</a></li><li><a href=#secondary-index-大小>Secondary Index 大小</a></li><li><a href=#uuid-寫入的影響>UUID 寫入的影響</a></li></ol></li><li><a href=#延伸閱讀>延伸閱讀</a><ol><li><a href=#為什麼-wiredtiger-一開始不支援-clustered-index>為什麼 WiredTiger 一開始不支援 Clustered Index</a></li></ol></li><li><a href=#結語>結語</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E8%B3%87%E6%96%99%E5%BA%AB/>資料庫</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/posts/2023/2023-05-05-mongodb-clustered-collection-%E8%88%87-benchmark-%E5%AF%A6%E9%A9%97/>MongoDB Clustered Collection 與 Benchmark 實驗</a></h2><h3 class=article-subtitle>MongoDB 在 5.3 加入了 Clustered Collection 宣稱可以增加讀寫的效能，試著去了解背後的原理與用 benchmark 實測看看</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>May 05, 2023</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>4 minute read</time></div></footer></div></header><section class=article-content><p>最近看到一篇很不錯的文章<a class=link href=https://medium.com/@hnasr/mongodb-internal-architecture-9a32f1403d6f target=_blank rel=noopener>MongoDB internal Architecture</a>，主要在描述 MongoDB Storage Engine 的演進</p><p>其中在 5.3 比較大的改變是引入了 <code>Clustered Collection</code> 調整了 Storage Engine 儲存的機制，這也連帶影響 MongoDB 在 Collection 上的效能表現，以下從文章中摘要 Storage Engine 演進，並透過 Benchmark 去驗證看看實際的表現</p><h2 id=mongodb-storage-engine-演進>MongoDB Storage Engine 演進</h2><h3 id=mmapv1>MMAPv1</h3><p>最一開始 MongoDB 的 Storage Engine 是 MMAPv1，採用 B+Tree 架構以 <code>_id</code> 為 primary key，leaf node 儲存 <code>DiskLoc</code> 直接指向儲存於硬碟上的位置(透過 file name + offset)
<img src=https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M_5Io7l_SDSP_HSeH1iYaQ.png loading=lazy></p><p>MMAPv1 的優點是查詢速度很快，只需要 O(logN) 在 B+Tree 找到 leaf node + O(1) 去硬碟讀取資料即可</p><p>但有幾個重大缺點</p><ol><li>因為是儲存實際 Disk 位置，所以當 <code>document 因為 insert / update / delete 而改變 Disk 位置</code> 時，就需要大規模的改寫 DiskLoc 造成效能的影響</li><li>儲存時沒有壓縮</li><li>一開始只提供 database level / collection level 的 lock，這也導致在 parallel 執行上效率不高</li></ol><p>最終在 <a class=link href=https://www.mongodb.com/docs/v6.0/release-notes/4.2-compatibility/ target=_blank rel=noopener>MongoDB v4.2 就全面移除了</a></p><h3 id=wiredtiger>WiredTiger</h3><p>MongoDB 在 2014 年收購了 <a class=link href=https://source.wiredtiger.com/11.0.0/index.html target=_blank rel=noopener>WiredTiger</a> 這個 Storage Engine，並於 3.0 加入於 3.2 變成預設的 Storage Engine</p><p>在儲存上同樣是採用 B+Tree 結構，但這時候 <code>_id</code> 不是 Clustered Index Key 而是在內部 <code>WiredTiger 會自動為每個 document 設定 recordId 當作儲存排序的依據</code></p><p>所以 <code>_id</code> 跟其他 secondary index 相同，都是先在自己的 B+Tree 上查找，找到對應的 recordId 後再去 <code>recordId Clustered Index</code> 搜尋</p><p><img src=https://miro.medium.com/v2/resize:fit:1400/format:webp/1*urhOmzoY-JvXggjwRm9V-w.png loading=lazy></p><p>也因此 WiredTiger 的缺點是查詢變慢一些，因為需要搜尋兩次 B+Tree 才能去 Disk 撈資料</p><p>但有幾項優點</p><ol><li>Insert、Update、Delete 效能比 MMAPv1 穩定</li><li>提供 document level lock，大幅改善 parallel 效能</li><li>壓縮 BSON 在儲存，減少 Disk 用量代表可放進 buffer pool 的資料筆數也增加</li></ol><p>根據這篇文章 <a class=link href=http://smalldatum.blogspot.com/2015/07/linkbench-for-mysql-mongodb-with-cached.html target=_blank rel=noopener>Linkbench for MySQL & MongoDB with a cached database</a> 的實驗可以看到 MongoDB WiredTiger 在查詢與寫入都吊打其他的 Storage Engine
<img src=http://3.bp.blogspot.com/-Hrkm07TpHYY/VZqVFtZrgaI/AAAAAAAABm4/LQEN2-HfQDw/s1600/image%2B%25288%2529.png loading=lazy></p><p>有趣的是 MySQL 寫入、查詢吊打 MongoDB XD<br>在單機的環境下看起來老牌 RDBMS 比較厲害，只是實際選擇還需要再考量到 scalability 等狀況</p><h3 id=wiredtiger-clustered-collection-原理>WiredTiger Clustered Collection 原理</h3><p>接著到了 MongoDB 5.3 的 Clustered Collection，剛剛有提到實際內部儲存依據是用 <code>recordId</code> 排序，那如果直接拿 <code>_id 當作 Clustered Index 的 key</code> 是不是就能更加速寫入跟查詢的效率？這正是 Clustered Collection 所採用的方式，直接拿 _id 當作 Clustered Index</p><p><img src=https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zOQO6cVCj9PJ-HOWP6zmfw.png loading=lazy></p><p>根據官方文件，在建立 Clustered Collection 就必須指定用 _id 建立，同時必須是 unique</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=n>client</span><span class=o>[</span><span class=s2>&#34;collection&#34;</span><span class=o>].</span><span class=n>create</span><span class=p>({</span>
</span></span><span class=line><span class=cl>    <span class=ss>:clustered_index</span> <span class=o>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=ss>:key</span> <span class=o>=&gt;</span> <span class=p>{</span> <span class=ss>:_id</span> <span class=o>=&gt;</span> <span class=mi>1</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=ss>:unique</span> <span class=o>=&gt;</span> <span class=kp>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></td></tr></table></div></div><p>根據<a class=link href=https://www.mongodb.com/docs/upcoming/core/clustered-collections/ target=_blank rel=noopener>文件 Clustered Collections</a>所述有幾個優點</p><ol><li>大幅度增加 _id 搜尋速度，尤其是 range scan 上，因為少了一次去查找 recordId index</li></ol><blockquote><p>Faster queries on clustered collections without needing a secondary index, such as queries with range scans and equality comparisons on the clustered index key.</p></blockquote><ol start=2><li>增加 CRUD 的效能</li></ol><blockquote><p>Clustered collections have additional performance improvements for inserts, updates, deletes, and queries.</p></blockquote><p>但也不是全然沒有壞處</p><ol><li>Secondary Index leaf node 會儲存 Clustered Index 的 key，而因為前面提到原本 collection Clustered Index 是用 recordId(8byte)，而 _id 預設是 12byte，所以就直接影響了 Secondary Index 的 size (增加約 20%)</li><li><code>_id 是用戶可以預設，如果設錯可能會讓效能變差</code></li></ol><p>整體來說目前 MongoDB Clustered Collection 儲存方式有點接近 MySQL，同樣都是</p><ol><li>指定 Primary Key 當作 Clustered Index 影響實際儲存的方式</li><li>Secondary Index leaf node 指向 Clsutered Index</li></ol><p>同樣的如果 _id 是採用 UUID 等亂序，也同樣會有效能上的影響，這部分可以參考 <a class=link href=https://www.percona.com/blog/uuids-are-popular-but-bad-for-performance-lets-discuss/ target=_blank rel=noopener>UUIDs are Popular, but Bad for Performance — Let’s Discuss</a>，這點後續 benchmark 會驗證</p><h2 id=benchmark>Benchmark</h2><p>透過以下幾個實驗來實際檢驗一下 MongoDB v6.0.5 Clustered Collection 的效能</p><ol><li>比對 CRUD 在 Clustered Collection vs 一般 Collection 差異<br>預期 CRUD 在 Clustered Collection 應該要較好</li><li>針對 Secondary Index，比較實際大小與效能<br>預期 Secondary Index 在 Clustered Collection 儲存空間要比較大，如果尺寸沒有大到記憶體塞不下的狀況，效能部分預期是差不多</li><li>_id 改用 UUID 對於寫入效能的影響<br>預期 Clustered Collection 會有比較差的表現，因為底層儲存結構的關係</li></ol><p>相關程式碼在 <a class=link href=https://github.com/sj82516/mongodb-bm-cluster-collection target=_blank rel=noopener>sj82516/mongodb-bm-cluster-collection</a></p><h3 id=insert-比較>Insert 比較</h3><p><img src=/post/2023/img/0505/insert.png loading=lazy></p><p>實驗每個 iteration 準備 100 萬筆資料並用 insert_many 批次寫入 1000 筆，總共插入 2000 萬筆；實驗組是 clustered collection 但對照組不是</p><p>從圖表來看 Clustered Collection 有稍微比較好但沒有到非常明顯的變化</p><h3 id=search-比較>Search 比較</h3><p>測試過程有發現一個 MongoDB 的 bug <a class=link href=https://jira.mongodb.org/browse/SERVER-76905 target=_blank rel=noopener>Performance Issue about Clustered Collection : where there are more than one _id search condition, the search would fallback to COLLSCAN</a>，主要是 find 條件中有多個 _id 時 index 會沒有吃到 clustered index 導致查詢非常慢</p><p>但有趣的是 secondary index 目前測試是沒有這個問題的</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       user     system      total        real
</span></span><span class=line><span class=cl>cluster search  1.011011   0.095830   1.106841 ( 27.275139)
</span></span><span class=line><span class=cl>normal search  0.405232   0.034662   0.439894 (  0.449653)
</span></span><span class=line><span class=cl>       user     system      total        real
</span></span><span class=line><span class=cl>cluster email search  0.417697   0.035939   0.453636 (  0.556692)
</span></span><span class=line><span class=cl>normal email search  0.407986   0.027175   0.435161 (  0.487835)
</span></span></code></pre></td></tr></table></div></div><p>可以看到 cluster search 慢到爆，delete_many 有同樣的 issue</p><p><img src=/post/2023/img/0505/index_issue.png loading=lazy>
本來以為是不是 driver 問題，但實際用 Mongo Compass 官方 GUI tool 去分析查詢，確實發現只要 $in 裡面的條件超過一筆就會變成 COLLSCAN</p><h3 id=secondary-index-大小>Secondary Index 大小</h3><p><img src=/post/2023/img/0505/sec.png loading=lazy></p><p>可以看出同樣的 documents 下 Secondary Index 在 Clustered Index 確實變大快 25%</p><h3 id=uuid-寫入的影響>UUID 寫入的影響</h3><p><img src=/post/2023/img/0505/uuid.png loading=lazy><br>實驗每個 iteration 準備 100 萬筆資料並用 insert_many 批次寫入 1000 筆，兩個 collection 都是 clustered collection，實驗組 _id 設定為 UUID</p><p>可以看到 UUID 對於效能的負面影響十分巨大</p><h2 id=延伸閱讀>延伸閱讀</h2><p>以下是我在閱讀時想到的一些額外問題，覺得蠻有趣也順便記錄一下</p><h3 id=為什麼-wiredtiger-一開始不支援-clustered-index>為什麼 WiredTiger 一開始不支援 Clustered Index</h3><p>既然有這麼大的好處，為什麼一開始不支援呢？在這個 google group discuss 有稍微帶到 <a class=link href=https://groups.google.com/g/mongodb-dev/c/8dhOvNx9mBY target=_blank rel=noopener>Purpose of a separate index storage for primary id for MongoDB</a></p><p>理解起來比較像技術債，一開始 MMAPv1 是使用 DiscLoc，後來 WiredTiger 改成用 RecordId 而不是直接綁死 Disk 位置</p><blockquote><p>the origin of this decision was the MMAPv1 storage engine. There, indexes would map keys to <code>'DiskLoc' values, containing a pair of 32-bit integers representing the file number in the database and offset in that file.</code> Since then we have replaced DiskLoc by a RecordId that does not represent a physical location, but rather a logical document number.</p></blockquote><p>另外就是 MongoDB 對於 Primary Key 使用有額外的用途，包含 Sharding，所以實作比想像中複雜
另外也有提到即使有效能上的提升但對於 Secondary Index 是有負面影響</p><blockquote><p>we could gain efficiency (both time and space) by using the primary key directly to index the data. However, as MongoDB puts few restrictions on the primary key, it is common for these primary keys to have a non-trivial size. <code>This in turn means that all secondary indexes become less efficient. Some users have many indexes, so they'd be negatively affected by such a change.</code> &mldr;&mldr;</p></blockquote><h2 id=結語>結語</h2><p>整體來說 Clustered Collection 寫入效能確實有好上一些，搜尋部分因為有 bug 暫時還不確定，而 Secondary Index 體積會有感的變大；目前整題評估下來不建議採用 Clustered Collection，些微的效益比不上這些風險與副作用</p></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/posts/2022/2022-04-25-mysqllock-%E8%88%87-index-%E9%97%9C%E4%BF%82%E5%92%8C-deadlock-%E5%88%86%E6%9E%90/><div class=article-details><h2 class=article-title>【MySQL】Lock 與 Index 關係和 Deadlock 分析</h2></div></a></article><article><a href=/posts/2022/2022-04-02-ddia03-%E8%B3%87%E6%96%99%E5%BA%AB%E5%84%B2%E5%AD%98%E5%8E%9F%E7%90%86%E7%A0%94%E7%A9%B6/><div class=article-details><h2 class=article-title>【DDIA】03 - 資料庫儲存原理研究</h2></div></a></article><article><a href=/posts/2021/2021-11-14-effective-sql%E8%AE%80%E5%BE%8C%E5%88%86%E4%BA%AB/><div class=article-details><h2 class=article-title>《Effective SQL》讀後分享</h2></div></a></article><article><a href=/posts/2021/2021-10-10-mysql-replication-%E8%88%87-rds/><div class=article-details><h2 class=article-title>MySQL Replication 與 RDS</h2></div></a></article><article><a href=/posts/2021/2021-07-02-aws-aurora-%E6%9E%B6%E6%A7%8B%E7%A0%94%E7%A9%B6%E4%BB%A5%E5%8F%8A%E8%88%87%E8%87%AA%E9%A7%95-mysql-%E7%9A%84%E5%B7%AE%E7%95%B0/><div class=article-details><h2 class=article-title>AWS Aurora 架構研究以及與自駕 MySQL 的差異</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//yuanchieh.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2023 Yuanchieh</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.17.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>