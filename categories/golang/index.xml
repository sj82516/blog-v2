<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on Yuanchieh</title><link>https://yuanchieh.page/categories/golang/</link><description>Recent content in Golang on Yuanchieh</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 06 Jun 2021 01:21:40 +0000</lastBuildDate><atom:link href="https://yuanchieh.page/categories/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang 併發處理 Mutex / RWMutex / SingleFlight</title><link>https://yuanchieh.page/posts/2021/2021-06-06-golang-%E4%BD%B5%E7%99%BC%E8%99%95%E7%90%86-mutex-/-rwmutex-/-singleflight/</link><pubDate>Sun, 06 Jun 2021 01:21:40 +0000</pubDate><guid>https://yuanchieh.page/posts/2021/2021-06-06-golang-%E4%BD%B5%E7%99%BC%E8%99%95%E7%90%86-mutex-/-rwmutex-/-singleflight/</guid><description>&lt;p>在與公司前輩請教時，有聊到 Mutex , RWMutex 性能對比，以及併發下用 SingleFlight 避免擊穿問題，所以就花點時間看實作與練習，發現這系列寫得太好了 &lt;a class="link" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/" target="_blank" rel="noopener"
>6.2 同步原语与锁&lt;/a>，拜讀過後整理以下的提問&lt;/p>
&lt;h3 id="mutex-實作">Mutex 實作&lt;/h3>
&lt;p>分成兩種模式：一般模式與飢餓模式
取得 Lock 時&lt;/p>
&lt;ol>
&lt;li>沒有人佔用則直接取得&lt;/li>
&lt;li>有人占用時，如果判斷是否能進入自旋模式，所謂的自旋是透過消耗 CPU cylcles 的 buzy waiting，降低 context switch 的花費&lt;/li>
&lt;li>重新嘗試取得鎖，如果沒有取得鎖，等到時間超過 1ms 則進入飢餓模式，並等待信號 (runtime_SemacquireMutex)&lt;/li>
&lt;/ol>
&lt;h3 id="rwmutex-會產生-write-starvation-嗎">RWMutex 會產生 Write Starvation 嗎？&lt;/h3>
&lt;p>RWMutex 採用寫入優先，如果在取得 RWMutex 寫鎖時，發現目前有多個讀鎖&lt;/p>
&lt;ol>
&lt;li>先將 readerCount 變成負數，讓後續讀鎖都無法取得&lt;/li>
&lt;li>等到信號 writerSem 喚醒&lt;/li>
&lt;/ol>
&lt;p>讀鎖在取得時&lt;/p>
&lt;ol>
&lt;li>檢查 readerCount 是否為負數，如果是代表有寫鎖&lt;/li>
&lt;li>如果有寫鎖，則偵聽 readerSem 信號喚醒執行&lt;/li>
&lt;/ol>
&lt;p>在解除寫鎖 / 讀鎖，會分別去出發信號，讓等待的讀鎖 / 寫鎖開始執行&lt;/p>
&lt;h3 id="rwmutex-跟-mutex-效能比較">RWMutex 跟 Mutex 效能比較&lt;/h3>
&lt;p>實際測試的結果，設定一個寫入比率，單純比較取鎖/釋放鎖，跑一百萬次兩者差異不大&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="line">&lt;span class="cl">BenchmarkMutexTest-8 10000000 0.04064 ns/op
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">BenchmarkRWMutexTest
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">BenchmarkRWMutexTest-8 10000000 0.04699 ns/op
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">BenchmarkFakeWrite
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>加入了讀取跟寫入，有些測試會用 time.Sleep ，但我實驗因為同時跑 goroutine 關係，如果全部 goroutine 都在 sleep 會出錯，所以改用簡單的計數從零數到一百萬當作讀取，而寫入則是五倍的讀取時間&lt;/p>
&lt;p>寫入比例抓 0.2 的話，RWMutex 用起來有優勢很多&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="line">&lt;span class="cl">BenchmarkMutexTest
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">BenchmarkMutexTest-8 10000 58176 ns/op
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">BenchmarkRWMutexTest
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">BenchmarkRWMutexTest-8 10000 37176 ns/op
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>測試的程式碼在此 &lt;a class="link" href="https://github.com/sj82516/go-rwmutex-benchmark" target="_blank" rel="noopener"
>go-rwmutex-benchmark&lt;/a>&lt;/p>
&lt;p>總結&lt;/p>
&lt;blockquote>
&lt;p>RWMutex 測試起來效能蠻好的，在考量到讀取比較多的情況表現會比 Mutex 還要好&lt;/p>
&lt;/blockquote>
&lt;h2 id="singleflight">Singleflight&lt;/h2>
&lt;p>當 Server 在處理併發時，會避免大量重複的查詢操作進入 DB 中，這尤其會發生在 Cache 失效的當下，最理想狀況是&lt;code>所有同樣的查詢只要進 DB 查一次，其他查詢等待返回相同的結果&lt;/code>&lt;br>
這樣的情境可以使用 &lt;a class="link" href="https://medium.com/@vCabbage/go-avoid-duplicate-requests-with-sync-singleflight-311601b3068b" target="_blank" rel="noopener"
>Singleflight&lt;/a>，提供阻塞其餘查詢，只讓一個查詢發生的機制，並對外開放三個方法&lt;/p>
&lt;ul>
&lt;li>Do: 使用者指定 Key 與受保護的方法，同一時間只有一個保護方法會被執行，其餘進來的呼叫會等待&lt;/li>
&lt;li>DoChan: 同於 Do，但返回 channel，可以搭配 timeout 使用&lt;/li>
&lt;li>Forget: 有時候會希望主動讓 Key 不再保護，例如過了數秒為了避免讀取太舊的值，可以主動刪除 Key 讓下一個保護方法可以執行 (即使前者尚未返回)&lt;/li>
&lt;/ul>
&lt;p>更詳細內容可參考此篇 &lt;a class="link" href="https://medium.com/@vCabbage/go-avoid-duplicate-requests-with-sync-singleflight-311601b3068b" target="_blank" rel="noopener"
>Go: Avoid duplicate requests with sync/singleflight&lt;/a>，自己寫了一個簡單的範例 &lt;a class="link" href="https://play.golang.org/p/_uGNGjyMJ5f" target="_blank" rel="noopener"
>go playground&lt;/a>&lt;/p>
&lt;p>Singleflight 的實作也十分精練，用一個 map 保存 key 對應 struct，struct 裡面放 mutext 避免同步操作 / wg 讓其他呼叫發現有人在執行就乖乖等待 ，可參考 &lt;a class="link" href="https://segmentfault.com/a/1190000018464029" target="_blank" rel="noopener"
>golang防缓存击穿利器&amp;ndash;singleflight&lt;/a>&lt;/p>
&lt;h3 id="typescript-實作">typescript 實作&lt;/h3>
&lt;p>後來覺得頗有趣就自己實作一個 typescript 版本：&lt;a class="link" href="https://github.com/sj82516/go-singleflight" target="_blank" rel="noopener"
>sj82516/go-singleflight&lt;/a>，原本想要多一個儲存的 adpter 支援 redis，但卡在 Object / Error 要如何 serialize / deserialize 就先中止了&lt;/p>
&lt;h2 id="go-assembler">Go Assembler&lt;/h2>
&lt;p>往下追 &lt;code>&amp;quot;sync/atomic&amp;quot;&lt;/code> 發現沒有相關的 CompareAndSwapInt32 的程式碼，這是因為這些部分是在 runtime 產生，atomic 指令必須由 CPU 提供才能保證執行時的原子性，而指令則是各平台限定，如 x86 / x64 / arm 32 / arm 64 / powerpc 等等，這在編譯的時候可以透過 &lt;code>GOARCH / GOOS&lt;/code> 指定編譯的平台&lt;/p>
&lt;p>補充資料可以參考&lt;/p>
&lt;ol>
&lt;li>高階語言如何變成機器可執行的位元檔：&lt;a class="link" href="https://www.youtube.com/watch?v=N2y6csonII4" target="_blank" rel="noopener"
>Compiling, assembling, and linking&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.youtube.com/watch?v=KINIAgRpkDA" target="_blank" rel="noopener"
>GopherCon 2016: Rob Pike - The Design of the Go Assembler&lt;/a> / 文字說明 &lt;a class="link" href="https://medium.com/martinomburajr/go-tools-the-compiler-part-1-assembly-language-and-go-ffc42cbf579d" target="_blank" rel="noopener"
>Go Tools: The Compiler — Part 1 Assembly Language and Go&lt;/a>&lt;/li>
&lt;/ol>
&lt;p>Rob Pike 說明一開始 Go 的原始碼有使用 C/Yaac 完成編譯的方式，但因為難管理後來在 Go 1.3 開始汰換成 Go 實作&lt;/p>
&lt;p>這邊實作有趣的地方在於 Rob Pike 表示雖然每個平台的指令/暫存器名稱都不同，但是基本的使用可以被抽象化，所以 Go Compiler 會編譯出 semi pseudo code，接著依照指定的平台轉換成對應的 assembly code，這部分實作了 &lt;code>obj&lt;/code> library&lt;/p>
&lt;p>這樣的好處是對於 Compiler 來說產生 semi pseudo code 就是單純的文字轉換&lt;/p>
&lt;p>在影片中的範例&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-golang" data-lang="golang">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">ADDW&lt;/span> &lt;span class="nx">AX&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">BX&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">-----&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">obj&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Prod&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">As&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">arch&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Instructions&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s">&amp;#34;ADDW&amp;#34;&lt;/span>&lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">From&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">obj&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Addr&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">Reg&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">arch&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Register&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s">&amp;#34;AX&amp;#34;&lt;/span>&lt;span class="p">]},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">To&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">obj&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Addr&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">Reg&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">arch&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Register&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s">&amp;#34;BX&amp;#34;&lt;/span>&lt;span class="p">]}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最後提到他們在開發工具，直接讀 PDF 產生各平台對應的 instruction set
&lt;img src="https://yuanchieh.page/"
loading="lazy"
>&lt;/p>
&lt;p>在思考的過程中，開始想 assembly 夾在 source code / machine code 的地位，這一篇 SO 給出了回答 &lt;a class="link" href="https://stackoverflow.com/questions/51780158/why-do-we-even-need-assembler-when-we-have-compiler" target="_blank" rel="noopener"
>Why do we even need assembler when we have compiler?&lt;/a>&lt;br>
正如同夾在中間的地位，machine code 人類無法讀，source code 又太 high level，如果要確認 compiler 是否編譯出有效的 machine code，那查看 assembly 看實際人類可讀的指令是最好的&lt;/p>
&lt;p>Go 編譯過程可參考 &lt;a class="link" href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/" target="_blank" rel="noopener"
>Go 语言设计与实现 &lt;/a>&lt;/p>
&lt;p>存參個在 SO 上被扣分的發問 &lt;a class="link" href="https://stackoverflow.com/questions/67855719/why-assembly-is-unportable?noredirect=1#comment119941280_67855719" target="_blank" rel="noopener"
>Why assembly is unportable&lt;/a>，comment 有很多解釋之後慢慢細讀再補充&lt;/p></description></item><item><title>Golang Test - 單元測試、Mock與http handler 測試</title><link>https://yuanchieh.page/posts/2021/2021-03-18-golang-test/</link><pubDate>Thu, 18 Mar 2021 08:21:40 +0000</pubDate><guid>https://yuanchieh.page/posts/2021/2021-03-18-golang-test/</guid><description>&lt;p>上過 91 老師的 TDD 後，開始注重程式語言支援的測試框架，&lt;code>編寫測試代碼與寫出容易寫測試的代碼&lt;/code>是很重要的一件事，好測試的代碼通常好維護，因為通常代表有更低的耦合性、物件依賴關係明確等，說是「通常」也代表不是這麼絕對；但反之 &lt;code>不容易寫測試的代碼&lt;/code>往往都是有奇怪 smell 的&lt;/p>
&lt;p>關於測試案例的種類請參考 91 老師的 &lt;a class="link" href="https://dotblogs.com.tw/hatelove/2012/11/29/learning-tdd-in-30-days-day7-unit-testing-stub-mock-and-fake-object-introduction" target="_blank" rel="noopener"
>Unit Test - Stub, Mock, Fake 簡介&lt;/a>&lt;/p>
&lt;p>以下將分享如何在 Golang 中編寫&lt;/p>
&lt;ul>
&lt;li>單元測試&lt;/li>
&lt;li>如何 Stub/Mock 外部相依&lt;/li>
&lt;li>如何針對 http handler 做 http request 假請求檢查&lt;/li>
&lt;/ul>
&lt;p>自己開始真正寫 Golang 也是這幾個禮拜，有一些命名、寫法不正確，煩請指教，但針對測試的本身應該是沒什麼問題的&lt;br>
目前採用 &lt;code>Ginkgo&lt;/code> + &lt;code>gomock&lt;/code> + &lt;code>httptest&lt;/code> 組合的測試工具&lt;/p>
&lt;p>以下我們將寫一個簡單的匯率兌換表，用戶輸入既有的幣別 / 欲兌換的幣別 / 數量，Server 回傳兌換後的數量，程式碼於此 &lt;a class="link" href="https://github.com/sj82516/golang-exchange-currency" target="_blank" rel="noopener"
>golang-exchange-currency&lt;/a>&lt;/p>
&lt;p>以下是程式碼結構&lt;/p>
&lt;ul>
&lt;li>main.go: 啟動 http server&lt;/li>
&lt;li>src/exchange_currency_model.go: 模擬去資料庫讀取匯率兌換表&lt;/li>
&lt;li>src/currency_exchange_handler.go: http handler，處理 request 與 response&lt;/li>
&lt;/ul>
&lt;h2 id="單元測試">單元測試&lt;/h2>
&lt;p>首先要決定測試框架，這部分評估過 &lt;code>原生的testing&lt;/code>、&lt;code>Testify&lt;/code>，最後選擇了 &lt;a class="link" href="https://onsi.github.io/ginkgo/#getting-ginkgo" target="_blank" rel="noopener"
>&lt;code>Ginkgo&lt;/code>&lt;/a>，最大原因是熟悉原本 Nodejs的 &lt;code>Decribe / It&lt;/code> 組織 test case 的方式，以及有方便的 BeforeEach 可以抽出重複測試行為的部分，例如在每個測試案例之前都先 new 好 object&lt;br>
這些在 testing / Testify 都要額外的功夫處理&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-golang" data-lang="golang">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span> &lt;span class="s">&amp;#34;github.com/onsi/ginkgo&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span> &lt;span class="s">&amp;#34;github.com/onsi/gomega&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">var&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">Describe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;currency exchange&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">c&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">CurrencyExchangeHandler&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">...&lt;/span>&lt;span class="p">.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">BeforeEach&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">c&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">NewCurrencyExchangeHandler&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">e&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">It&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;should get 0 if amount is 0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">done&lt;/span> &lt;span class="nx">Done&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">...&lt;/span>&lt;span class="p">.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">Expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Exchange&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;US&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;TW&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)).&lt;/span>&lt;span class="nf">To&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">Equal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">done&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">...&lt;/span>&lt;span class="p">.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="stubmock">Stub/Mock&lt;/h2>
&lt;p>&lt;code>Stub&lt;/code> 專注於測試物件本身，只是把外部相依的方法塞一個設定值回傳；&lt;br>
&lt;code>Mock&lt;/code> 則延伸 Stub，除了塞回傳值外，而外檢查被呼叫物件的傳入值 / 呼叫次數 / 狀態改變等非測試物件本身的狀態&lt;/p>
&lt;p>在 Golang 中，使用 &lt;a class="link" href="https://github.com/golang/mock" target="_blank" rel="noopener"
>&lt;code>gomock&lt;/code>&lt;/a> 真的是超級方便，可以直接針對檔案產出對應的 mock 檔 exchange_price_model_mock.go，這邊要注意 mock 是針對 interface 產生，所以如果你的檔案中沒有 interface，mock 檔出來就會是空的&lt;/p>
&lt;p>所以我在 exchange_price_model.go 中有定義&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-golang" data-lang="golang">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">IExchangePriceModel&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">GetExchangeRate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">chan&lt;/span>&lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="nx">ExchangeRateResult&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接著執行 &lt;code>mockgen -source={要 mock 的檔案} -destination={輸出位置} -package={package 名稱}&lt;/code>，例如 &lt;code>$ mockgen -source=exchange_price_model.go -destination=exchange_price_model_mock.go -package=src&lt;/code>，mockgen 是 gomock 用來產生 mock 檔案的 binary 執行工具&lt;/p>
&lt;p>之後測試案例採用 &lt;code>NewMockIExchangePriceModel&lt;/code> 這個由 mockgen 產生的 struct 即可&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-golang" data-lang="golang">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">var&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">Describe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;currency exchange&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">c&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">CurrencyExchangeHandler&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">mockCtrl&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">gomock&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Controller&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">e&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">MockIExchangePriceModel&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">BeforeEach&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">mockCtrl&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">gomock&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewController&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">GinkgoT&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">e&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">NewMockIExchangePriceModel&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mockCtrl&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">c&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">NewCurrencyExchangeHandler&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">e&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">It&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;should get 0 if amount is 0&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">done&lt;/span> &lt;span class="nx">Done&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">EXPECT&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nf">GetExchangeRate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;US&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;TW&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">gomock&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Any&lt;/span>&lt;span class="p">()).&lt;/span>&lt;span class="nf">Do&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">from&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">to&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ch&lt;/span> &lt;span class="kd">chan&lt;/span>&lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="nx">ExchangeRateResult&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="nx">ExchangeRateResult&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">IsExists&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ExchangeRate&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">40&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">Expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Exchange&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;US&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;TW&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)).&lt;/span>&lt;span class="nf">To&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">Equal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">done&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">...&lt;/span>&lt;span class="p">.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>編寫 mock 的方式如下&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-golang" data-lang="golang">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">EXPECT&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nf">Method&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;預期 method 要收到的參數&amp;#34;&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nf">Do&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;實際執行時收到的參數&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">做任何造假&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>等於是寫一次連&lt;code>預期輸入&lt;/code>、&lt;code>造假輸出&lt;/code>都一並做完，如果要方便可以 &lt;code>.Return()&lt;/code> 直接寫回傳內容，但因為涉及 channel 要傳遞資料，所以我選擇 .Do() 並塞入造假的資料回傳 channel&lt;/p>
&lt;p>如果不在意預期輸入，可以都用 &lt;code>gomock.Any()&lt;/code> 跳過檢查&lt;/p>
&lt;h3 id="如何造假-timenow-等系統相依的函式">如何造假 Time.Now 等系統相依的函式&lt;/h3>
&lt;p>搜尋了一下這類問題，建議是把有外部相依都抽到另一個 Object 去，然後透過依賴注入的方式傳進去，才能夠造假&lt;/p>
&lt;p>例如&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-golang" data-lang="golang">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">ObjectA&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">ObjectA&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">MethodA&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">MethodB&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">ObjectA&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">MethodB&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">Time&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Now&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>這樣是無法測試的，要拆解成&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-golang" data-lang="golang">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">interface&lt;/span> &lt;span class="nx">IObjectB&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">MethodB&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">ObjectA&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ObjB&lt;/span> &lt;span class="nx">IObjectB&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">ObjectA&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">MethodA&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">a&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ObjB&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">MethodB&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在使用 Interface 替換過程，要注意 *Type 跟 Type 的差異，如果發現以下錯誤訊息請參考 &lt;a class="link" href="https://stackoverflow.com/questions/40823315/x-does-not-implement-y-method-has-a-pointer-receiver" target="_blank" rel="noopener"
>X does not implement Y (… method has a pointer receiver)&lt;/a>&lt;br>
從問答中回去文件看，可以注意到以下內容
&lt;a class="link" href="https://golang.org/ref/spec#Method_sets" target="_blank" rel="noopener"
>Method sets ¶&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">The method &lt;span class="nb">set&lt;/span> of any other &lt;span class="nb">type&lt;/span> T consists of all methods declared with receiver &lt;span class="nb">type&lt;/span> T. The method &lt;span class="nb">set&lt;/span> of the corresponding pointer &lt;span class="nb">type&lt;/span> *T is the &lt;span class="nb">set&lt;/span> of all methods declared with receiver *T or T &lt;span class="o">(&lt;/span>that is, it also contains the method &lt;span class="nb">set&lt;/span> of T&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>這一段也就是說&lt;/p>
&lt;ul>
&lt;li>如果 method 宣告的 reciever 是 non pointer type &lt;code>func (t T) method&lt;/code>，則 T / *T 都有包含此 method&lt;/li>
&lt;li>但如果 method 宣告的 reciever 是 pointer type，則只有 *T 包含此 method&lt;/li>
&lt;/ul>
&lt;p>延伸至 embedded struct&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">- If S contains an embedded field T, the method sets of S and *S both include promoted methods with receiver T. The method &lt;span class="nb">set&lt;/span> of *S also includes promoted methods with receiver *T.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- If S contains an embedded field *T, the method sets of S and *S both include promoted methods with receiver T or *T.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果是&lt;/p>
&lt;ul>
&lt;li>S 是 non pointer，且 T 也是 non pointer，則包含了 T non pointer type methods&lt;/li>
&lt;li>S 是 non pointer + T 是 pointer / 只要 S 是 pointer type，則包含了 T non pointer / pointer type methods&lt;/li>
&lt;/ul>
&lt;p>詳見程式碼，我把 struct 有的 method 都列出來，可以清楚看到以上的規則 &lt;a class="link" href="https://play.golang.org/p/jkYrqF4KyIf" target="_blank" rel="noopener"
>Go playground&lt;/a>&lt;/p>
&lt;p>另外抽出依賴再注入，如果忘記初始化會有記憶體存取失敗的錯誤 &lt;code>http: panic serving runtime error: invalid memory address or nil pointer dereference&lt;/code>，看到錯誤記得去檢查&lt;/p>
&lt;h2 id="針對-http-handler-做檢查">針對 HTTP Handler 做檢查&lt;/h2>
&lt;p>透過單元測試與 Stub/Mock，可以檢查完商業邏輯的部份，但如果想更確定 server 是否有正確處理 http request，包含是否回傳預期的錯誤結果，可以再進一步針對 http handler 做測試&lt;/p>
&lt;p>這邊採用 core library 包含 &lt;code>net/http/httptest&lt;/code> 測試，完整教學可以參考 &lt;a class="link" href="https://blog.questionable.services/article/testing-http-handlers-go/" target="_blank" rel="noopener"
>Testing Your (HTTP) Handlers in Go&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-golang" data-lang="golang">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">It&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;test ServeHttp integration&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">done&lt;/span> &lt;span class="nx">Done&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">EXPECT&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="nf">GetExchangeRate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">gomock&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Any&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="nx">gomock&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Any&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="nx">gomock&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Any&lt;/span>&lt;span class="p">()).&lt;/span>&lt;span class="nf">Do&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">from&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">to&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ch&lt;/span> &lt;span class="kd">chan&lt;/span>&lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="nx">ExchangeRateResult&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ch&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="nx">ExchangeRateResult&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">IsExists&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">ExchangeRate&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">ch&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">req&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewRequest&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;GET&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;/exchange-currency&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">query&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">req&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">URL&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Query&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">query&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;from&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;US&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">query&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;to&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;TW&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">query&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;amount&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;10&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">req&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">URL&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">RawQuery&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">query&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Encode&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">rr&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">httptest&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">NewRecorder&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">e&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">ExchangePriceModel&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">c&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">CurrencyExchangeHandler&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">E&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nx">e&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">handler&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">HandlerFunc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">ServeHTTP&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">handler&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ServeHTTP&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">rr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">req&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">Expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">rr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Code&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nf">To&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">Equal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">200&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">body&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">Amount&lt;/span> &lt;span class="kt">int&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">_&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">json&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Unmarshal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">rr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Body&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Bytes&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">body&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">Expect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">body&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Amount&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="nf">To&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">Equal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">300&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">close&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">done&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>以上基本就是造假 / 初始化 handler / 初始化 http request / 透過 &lt;code>handler.ServeHTTP(rr, req)&lt;/code> 模擬 http handler 處理過程 / 檢查 response&lt;/p>
&lt;p>基本上 Context / Cookie 等都可以處理，處理起來相當方便&lt;/p>
&lt;h2 id="結語">結語&lt;/h2>
&lt;p>從動態語言過來，最不習慣的就是要一直去想物件之間的相依，包含要處理 mock 時要拆出 interface 與外部物件，而不能針對某一個 object 的某一個 method 造假&lt;/p>
&lt;p>但整體上，Golang 的測試算方便且好上手，~找不到偷懶不寫測試的理由了~&lt;/p></description></item><item><title>從 Nodejs 到 Golang: Concurrency 實作比較</title><link>https://yuanchieh.page/posts/2021/2021-03-07-%E5%BE%9E-nodejs-%E5%88%B0-golang-concurrency-%E5%AF%A6%E4%BD%9C%E6%AF%94%E8%BC%83/</link><pubDate>Sun, 07 Mar 2021 08:21:40 +0000</pubDate><guid>https://yuanchieh.page/posts/2021/2021-03-07-%E5%BE%9E-nodejs-%E5%88%B0-golang-concurrency-%E5%AF%A6%E4%BD%9C%E6%AF%94%E8%BC%83/</guid><description>&lt;p>在一兩年前 Golang 很火紅時有學了一下，但當時沒有深入的理解 Golang 相對於其他語言的特色與魅力，只停留在表層的語法學習，時隔多年因為換工作的需求，重學 Golang 發現有蠻多有趣的地方，拿來與 Nodejs 相比有許多類似但不同的實作差異，尤其在非同步這一塊，特此筆記並分享如何從 Nodejs 跳槽到 Golang&lt;/p>
&lt;p>本篇將著重於介紹 Golang 上手的教學資源，以及對比 Nodejs (Javascript)，Golang 的特色在什麼地方&lt;/p>
&lt;h2 id="golang-與-nodejs-異同之處---以非同步為例">Golang 與 Nodejs 異同之處 - 以非同步為例&lt;/h2>
&lt;p>Golang 與 Nodejs 在非同步設計上有些雷同之處，相較於傳統的每一個 IO 事件就開一個 thread 讓 OS 去排程，&lt;code>Nodejs 與 Golang 都盡可能減少 kernel thread 的產生，而是透過 Non blocking system call 或是 user thread 與 scheduler 方式，降低 OS Context Switch 就能更有效率使用 kernel thread&lt;/code>&lt;/p>
&lt;h3 id="nodejs-內部非同步處理">Nodejs 內部非同步處理&lt;/h3>
&lt;p>透過 runtime 底層 &lt;code>libuv&lt;/code> 呼叫 non-blocking system call，向 system 註冊有興趣的事件並加入 event loop ，event loop 中又細分成多個 phase 檢查不同的任務如 timer / io / check 等，等到 main thread 執行完後檢查 event loop 上 IO 事件是否完成，如果完成則觸發 callback 到 main thread 執行&lt;/p>
&lt;p>但需要注意 Nodejs core library 有些是沒有 non blocking system call，例如 fs / crypto / dns.lookup 查詢，這些是從 Worker Pool 另外開 thread 執行，會受限於環境變數 UV_THREADPOOL_SIZE 控制整體 kernel thread 數量，所以再次提醒 &lt;code>Nodejs runtime 是 multi thread，只是 js 跟 event loop callback 都跑在同一個 main thread 上&lt;/code>，具體可以參考&lt;/p>
&lt;ol>
&lt;li>&lt;a class="link" href="https://www.youtube.com/watch?v=zphcsoSJMvM" target="_blank" rel="noopener"
>The Node.js Event Loop: Not So Single Threaded&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.youtube.com/watch?v=P9csgxBgaZ8" target="_blank" rel="noopener"
>Node&amp;rsquo;s Event Loop From the Inside Out by Sam Roberts, IBM&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="http://docs.libuv.org/en/v1.x/guide/basics.html" target="_blank" rel="noopener"
>Basics of libuv&lt;/a>&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>Instead, the application can request the operating system to watch the socket and put an event notification in the queue. The application can inspect the events at its convenience&lt;/p>
&lt;/blockquote>
&lt;p>如果是 core library 沒有支援的 non blocking 任務，就必須自己透過 worker_threads / child_process / cluster 等方式才不會 block main thread，這也是新手搞混的問題 &lt;code>是不是用 Promise 包成非同步就不會 blocking (X)&lt;/code>&lt;/p>
&lt;h3 id="golang-的-goroutine-與-scheduler">Golang 的 goroutine 與 scheduler&lt;/h3>
&lt;p>內容摘錄自這幾篇優良的內容：&lt;br>
&lt;a class="link" href="https://www.youtube.com/watch?v=YHRO5WQGh0k" target="_blank" rel="noopener"
>GopherCon 2018: Kavya Joshi - The Scheduler Saga&lt;/a> / &lt;a class="link" href="https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a" target="_blank" rel="noopener"
>Go: Goroutine, OS Thread and CPU Management&lt;/a> / &lt;a class="link" href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html" target="_blank" rel="noopener"
>Scheduling In Go : Part II - Go Scheduler&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>前情提要，processor 只能執行 kernel thread 任務，每個 kernel thread 在記憶體佔用與 context switcth 花費都不小 (8KB / 1 ms)&lt;br>
而 Golang 本身建立 user thread (goroutine)，開銷相對只要 (2KB/10 ns)
透過 Schedule 安排 user thread -&amp;gt; kernel thread -&amp;gt; processor 實際運行程式，盡可能讓 kernel thread 持續保持 running 減少 context switch&lt;/p>
&lt;/blockquote>
&lt;p>Golang 本身有 Scheduler 負責排程，透過 &lt;code>go func()&lt;/code>啟動 goroutine (user thread)，此 user thread 將由 Scheduler 排程&lt;br>
&lt;img src="https://www.ardanlabs.com/images/goinggo/94_figure11.png"
loading="lazy"
alt="來自參考文件"
>&lt;br>
(來自參考文件)&lt;/p>
&lt;ol>
&lt;li>Scheduler 預設為啟動一個 Processor P1，這裡會對應到硬體上可獨立執行 thread 的運算單元&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>不一定等於 CPU core 數量，因為像 intel Hyper-Threading 功能，一個 physical core 可運行兩個 thread&lt;/p>
&lt;/blockquote>
&lt;ol start="2">
&lt;li>Processor P1 上運行一個 Kernel Thread M1，並將 goroutine G1 排程到 M1 中執行&lt;/li>
&lt;li>如果有新的 goroutine G2 誕生，且目前的 Processor P1還在跑，則建立新的 kernel thread M2與 Processor P2，並執行 goroutine G2&lt;/li>
&lt;li>如果 kernel thread 啟動數量達到上限 &lt;code>GOMAXPROCS&lt;/code>，則會放到 FIFO queue 當中，簡稱 &lt;code>runq&lt;/code>，每個 Processor 都有對應自己的 local runq&lt;/li>
&lt;li>Processor 如果把 local run queue 都處理完，可以去偷其他 processor 的 runq (&lt;code>work stealing&lt;/code>)，達到工作 balance&lt;/li>
&lt;li>除了 local runq，還有一個 global runq 放被中斷的長時間佔用 goroutine，kernel thread 會用比較低的頻率去執行，還有像垃圾回收等任務&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-golang" data-lang="golang">&lt;span class="line">&lt;span class="cl">&lt;span class="nx">runtime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">schedule&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// only 1/61 of the time, check the global runnable queue for a G.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// if not found, check the local queue.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// if not found,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// try to steal from other Ps.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// if not, check the global runnable queue.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// if not found, poll network.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/blockquote>
&lt;ol start="7">
&lt;li>遇到 system call，會有兩種反應
&lt;ul>
&lt;li>如果是 &lt;code>blocking system call&lt;/code>，則該 kernel thread 會暫停 (parking) 並移出 processor，把 process 讓給其他人 (handoff)，此時 thread 不會佔用總體上限&lt;/li>
&lt;li>如果是 &lt;code>non blocking system call&lt;/code> 例如 network 相關，則不需要移出 thread，而是把 goroutine 放到 &lt;code>network poll&lt;/code>，processor 會在有空的時候去 network poll 找出完成 system call且 runnable 的 goroutine&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>這樣每個 process 都盡可能綁定一個 kernel thread，且此 kernel thread 就持續在 running 狀態而沒有切換，透過 Go Scheduler 替換 user thread 排程工作&lt;/p>
&lt;p>Scheduler 本身會在以下情況處理排程&lt;/p>
&lt;ul>
&lt;li>&lt;code>go&lt;/code> keyword&lt;/li>
&lt;li>垃圾回收：垃圾回收有獨立的 goroutine&lt;/li>
&lt;li>system call&lt;/li>
&lt;li>sync 相關呼叫: atomic / mutex / channel 相關操作，會導致 goroutine 堵塞&lt;/li>
&lt;/ul>
&lt;p>goroutine 可以針對 function level 啟動併發，也有豐富的同步語法，例如 sync.Mutex 保護 critical section / sync.WaitGroup 等待 goroutine 完成 / channel 在 goroutine 當中傳遞資料與控制執行&lt;/p>
&lt;h3 id="範例一透過-http-request-讀取-users-list-並再次透過-http-request-取得-10-位-user-的詳細資料算最後的性別加總">範例一：透過 http request 讀取 users list 並再次透過 http request 取得 10 位 user 的詳細資料，算最後的性別加總&lt;/h3>
&lt;p>範例只是要稍微品嚐一下兩個語法的差異，錯誤處理等就先不要太在意&lt;/p>
&lt;script src="https://gist.github.com/sj82516/6e10f70a62a1d717c78485077ff5a15d.js">&lt;/script>
&lt;p>這部分寫起來用 Nodejs 就蠻方便的&lt;/p>
&lt;h3 id="範例二計算-1000--1000-數字矩陣加總併發四個-thread-執行最後加總">範例二：計算 1000 * 1000 數字矩陣加總，併發四個 thread 執行最後加總&lt;/h3>
&lt;script src="https://gist.github.com/sj82516/df8e34f1ba7952817d3da2607c3eda35.js">&lt;/script>
&lt;p>Nodejs 在 child_process 或是 worker thread 我自己都覺得有點不太方便，不能針對某一個 function 起新的 thread，傳遞資料上也不是太方便，不如 Golang 直接 &lt;code>go func()&lt;/code> 搭配 channel 來的簡便&lt;/p>
&lt;p>接著回過頭來看，分享從 Nodejs 跳槽到 Golang 的學習方式&lt;/p>
&lt;h2 id="golang-教學資源推薦">Golang 教學資源推薦&lt;/h2>
&lt;p>影片付費資源：&lt;a class="link" href="https://app.pluralsight.com/paths/skills/go-core-language" target="_blank" rel="noopener"
>Go Core Language&lt;/a> ，自己本身蠻喜歡影片式教學，可以快速過一遍，Pluralsight 的課程品質還不錯，而且還有 Skill 可以測試自己的能力，把上面 Go 核心課程看完大概就花個 5個小時左右，覺得入門來說頗划算&lt;/p>
&lt;h2 id="為什麼要用-golang">為什麼要用 Golang&lt;/h2>
&lt;p>除了本身是靜態強型別的編譯式語言，Golang 相比於 Nodejs 語言本身有幾大特色讓我十分喜歡&lt;/p>
&lt;h3 id="1-非常工程導向簡潔">1. &lt;code>非常工程導向/簡潔&lt;/code>：&lt;/h3>
&lt;p>Golang 從一開始推出就是為了解決 Google 所遇到的大型軟體系統設計難題，所以從一開始設計就非常工程、團隊合作導向，例如&lt;/p>
&lt;ol>
&lt;li>只有 for loop 沒有 while / do while 等，讓寫法有統一的方式，不會每個人都有各自的實作&lt;/li>
&lt;li>package 中大寫代表 public / 小寫代表 private&lt;/li>
&lt;li>test function 必須是以 Test 開頭&lt;br>
Golang 只有 25 個 keywords，且在許多地方都有明確的限制，而不是給予空泛的自由，這讓團隊有明確的 coding style 可以遵守&lt;/li>
&lt;/ol>
&lt;h3 id="2-語言核心包含常用的功能例如-cli--testing">2. &lt;code>語言核心包含常用的功能，例如 CLI / Testing&lt;/code>&lt;/h3>
&lt;p>在 Nodejs 中，我們常需要各種 npm package 完成任務，小至 http request 都要安裝 node-fetch / axios / request 等，因為核心 library 提供的 api 不好用；
但是 Golang 中沒有這樣的問題，如果是要寫 CLI 工具，處理參數 / 產生 -help 文件等核心 library 都處理妥當；http request 用原生的 net/http 就很方便，甚至 api server 也都可以不用社群的 framework 就能夠快速實作&lt;/p>
&lt;h3 id="3-跨平台編譯出單一可執行的-binary-檔">3. &lt;code>跨平台編譯出單一可執行的 Binary 檔&lt;/code>&lt;/h3>
&lt;p>雖然有 Docker 提供跨平台部署的一致性保證，但是 Golang 可以直接編譯出對應平台可執行的 Binary 檔還是很方便，在寫 Dockerfile 也不用擔心太多環境設定是否正確 / 安裝過多套件是否有安全漏洞等等&lt;/p>
&lt;h3 id="4-官方文件齊全且詳盡">4. &lt;code>官方文件齊全且詳盡&lt;/code>&lt;/h3>
&lt;p>Golang 官網中的 &lt;a class="link" href="https://golang.org/doc/faq" target="_blank" rel="noopener"
>Frequently Asked Questions (FAQ)&lt;/a> 與 &lt;a class="link" href="https://blog.golang.org/" target="_blank" rel="noopener"
>The Go Blog&lt;/a>就有解答我許多疑惑，包含&lt;/p>
&lt;blockquote>
&lt;p>為什麼 Golang 要把型別宣告放在後面 &lt;a class="link" href="https://golang.org/doc/faq#different_syntax" target="_blank" rel="noopener"
>Why are declarations backwards?&lt;/a>
因為用口語念程式碼更直覺表達出意圖&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>為什麼要用 Go &lt;a class="link" href="https://blog.golang.org/two-recent-go-articles" target="_blank" rel="noopener"
>Two recent Go articles&lt;/a>&lt;br>
因為目前熱門的語言都是在網路/多核心時代前的產物，如C/C++/Java，像是thread 功能都是在語言誕生很久之後才設計的；另外現今系統的規模 / 協作人員等數量都完全不同，所以需要有新型態的語言來支援；&lt;br>
Go 具備&lt;code>快速編譯/跨平台支援/垃圾回收機制/goroutine 併發設計&lt;/code>，讓設計現代軟體更加簡便&lt;/p>
&lt;/blockquote>
&lt;p>官方就有豐富的資源可以讓開發者更深度的理解 Golang 設計精髓與奧妙&lt;/p>
&lt;h2 id="結語">結語&lt;/h2>
&lt;p>關於底層的 runtime 種種還有許多未解之謎，就等未來慢慢填坑，看著不同語言的發展與設計理念，覺得實在是有趣&lt;/p>
&lt;p>回歸工作，如果是一些簡單的任務，寫 Nodejs 還是蠻順手的；只是在大型軟體開發上，Golang 的設計理念 / 語言特性都讓他成為熱門的選擇，不愧是 Docker / K8s 等工具選擇的開發語言&lt;/p></description></item></channel></rss>