<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>雲端與系統架構 on Yuanchieh</title><link>https://yuanchieh.page/categories/%E9%9B%B2%E7%AB%AF%E8%88%87%E7%B3%BB%E7%B5%B1%E6%9E%B6%E6%A7%8B/</link><description>Recent content in 雲端與系統架構 on Yuanchieh</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 21 Jan 2021 08:21:40 +0000</lastBuildDate><atom:link href="https://yuanchieh.page/categories/%E9%9B%B2%E7%AB%AF%E8%88%87%E7%B3%BB%E7%B5%B1%E6%9E%B6%E6%A7%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>如何打造安全的 production ready Node.js Docker Image</title><link>https://yuanchieh.page/posts/2021/2021-01-21-%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E5%AE%89%E5%85%A8%E7%9A%84-production-ready-node.js-docker-image/</link><pubDate>Thu, 21 Jan 2021 08:21:40 +0000</pubDate><guid>https://yuanchieh.page/posts/2021/2021-01-21-%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E5%AE%89%E5%85%A8%E7%9A%84-production-ready-node.js-docker-image/</guid><description>&lt;p>要打造一個「可以動的 Docker Image」很簡單，參考 Node.js 官方文件 &lt;a class="link" href="https://node.js.org/en/docs/guides/node.js-docker-webapp/" target="_blank" rel="noopener"
>Dockerizing a Node.js web app&lt;/a> 就可以產出一個將近 &lt;code>1GB&lt;/code> 的 Docker Image&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">FROM node:14
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Create app directory&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">WORKDIR /usr/src/app
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Install app dependencies&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># A wildcard is used to ensure both package.json AND package-lock.json are copied&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># where available (npm@5+)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">COPY package*.json ./
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RUN npm install
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># If you are building your code for production&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># RUN npm ci --only=production&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Bundle app source&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">COPY . .
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">EXPOSE &lt;span class="m">8080&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CMD &lt;span class="o">[&lt;/span> &lt;span class="s2">&amp;#34;node&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;server.js&amp;#34;&lt;/span> &lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就開始想&lt;/p>
&lt;ol>
&lt;li>這樣安全嗎？&lt;/li>
&lt;li>可以打造更輕量、更好 ship 的 Image 嗎？&lt;/li>
&lt;/ol>
&lt;p>後來找到這一篇文章&lt;a class="link" href="https://snyk.io/blog/10-best-practices-to-containerize-node.js-web-applications-with-docker/" target="_blank" rel="noopener"
>10 best practices to containerize Node.js web applications with Docker&lt;/a>覺得十分實用，也解決安全性上的疑慮，以下摘要重點&lt;/p>
&lt;p>&lt;img src="https://yuanchieh.page/post/img/20210121/synk_docker.png"
loading="lazy"
alt="daily"
>&lt;/p>
&lt;h2 id="1-選擇正確的-base-image-並透過-build-stage-精簡產出">1. 選擇正確的 Base Image 並透過 Build Stage 精簡產出&lt;/h2>
&lt;blockquote>
&lt;p>tldr;&lt;/p>
&lt;ol>
&lt;li>採用 alpine 或 -slim 版本的 base image&lt;/li>
&lt;li>用 sha256 指定 base image 版本避免異動&lt;/li>
&lt;li>支援多階段，可以前期 build 用比較大的 base image，最後產出在使用精簡的 base image&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">FROM node:latest AS build
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">....
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --------------&amp;gt; The production image&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">FROM node:lts-alpine@sha256:b2da3316acdc2bec442190a1fe10dc094e7ba4121d029cb32075ff59bb27390a
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">....
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">COPY --from&lt;span class="o">=&lt;/span>build /usr/src/app/node_modules /usr/src/app/node_modules
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">....
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/blockquote>
&lt;p>進入 docker hub node.js 官方 image，可以看到玲琅滿目的版本，除了對應不同的 node.js 版本，底層的 os 可以分成幾種&lt;/p>
&lt;ol>
&lt;li>stretch: 基於 debian 9&lt;/li>
&lt;li>bulter: 基於 debian 10&lt;/li>
&lt;li>alpine: 基於 alpine linux&lt;/li>
&lt;/ol>
&lt;p>坦白說目前還不太理解 debian 9 / 10 真正的差異，而 alpine linux 目標是打造最輕量的 container os，最大差異在採用 musl libc 取代 glibc，如果使用的 js 套件有利用到 libc 可能會有問題&lt;/p>
&lt;p>而帶有 &lt;code>-slim&lt;/code> 結尾則是代表該 image 是最輕量可運行 Node.js 的 container os，也是官方建議在生產環境採用&lt;br>
例如說 &lt;code>node:14.15.4-stretch 尺寸 942MB&lt;/code> vs &lt;code>node:14.15.4-stretch-slim 尺寸 167MB&lt;/code>，前者連 build 工具都有包含如 python / node-gyp 等，這導致尺寸差異非常巨大&lt;br>
安裝越多工具的 Image，導致的潛藏性安全漏洞就越多，所以正式環境運行盡量採用 slim 版本&lt;/p>
&lt;p>所以最棒的是在第一階段採用完整 Image 方便 build node_modules，最後階段產出用精簡 Image 確保運行時沒有多餘的工具&lt;/p>
&lt;h2 id="2-確保只安裝-production-需要的-node-modules-並指定-node_env-為-production">2. 確保只安裝 production 需要的 node modules 並指定 NODE_ENV 為 production&lt;/h2>
&lt;blockquote>
&lt;p>透過 &lt;code>RUN npm ci --only=production&lt;/code> 只安裝 dependencies 而沒有 dev_dependencies 開發用的套件&lt;/p>
&lt;/blockquote>
&lt;p>npm ci 與 npm install 看似都在安裝套件但有很大的差異；&lt;br>
&lt;strong>npm ci&lt;/strong> 只讀取 lock file，並用 package.json 做比對，如果 lock file 與 package.json 版本不合會噴出錯誤，&lt;code>最適合用在要穩定且強一致的套件版本要求&lt;/code>&lt;br>
&lt;strong>npm install&lt;/strong> 則是讀取 package.json，並透過 lock file 做安裝的版本指定，如果有套件沒有出現在 lock file 中，則 npm 直接安裝&lt;/p>
&lt;p>運行環境，根據 Node.js 的不成文規定，請指定&lt;code>NODE_ENV=production&lt;/code>，各個套件都會針對 production 進行優化，另如文中舉例 express.js 會在生產環境加入頁面 cache 機制&lt;/p>
&lt;h2 id="3-不要用-root-運行-container">3. 不要用 root 運行 container!!&lt;/h2>
&lt;blockquote>
&lt;p>記得加入 &lt;code>USER node&lt;/code> 切換使用者，並記得 COPY 時要給予使用者相對權限 &lt;code>COPY --chown=node:node . /usr/src/app&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>這很重要，也很容易忘記，給予用戶不多不少的權限一直是安全性的基本準則，預設 docker container 內是以 root 運行 process，但如果不小心應用程式有漏洞，甚至有可能讓駭客跳脫 container context 獲得 host root 權限&lt;/p>
&lt;h2 id="4-正確接收程序中斷事件與優雅地退出">4. 正確接收程序中斷事件與優雅地退出&lt;/h2>
&lt;blockquote>
&lt;p>採用 dump-init 直接啟動 Node.js process&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">RUN apk add dumb-init
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CMD &lt;span class="o">[&lt;/span>&lt;span class="s2">&amp;#34;dumb-init&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;node&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;server.js&amp;#34;&lt;/span>&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>並記得在 Node.js 中偵測事件&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">process.on&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;SIGINT&amp;#39;&lt;/span>, closeGracefully&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">process.on&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;SIGTERM&amp;#39;&lt;/span>, closeGracefully&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/blockquote>
&lt;p>伺服器長時間運行時，總會遇到版本更新的時候，最理想的做法是讓中斷流量並讓程序完成剩餘工作後優雅退出，但如果採用的方式錯誤 Docker Container 會無法收到系統中斷的事件 &lt;code>SIGKILL&lt;/code> 、&lt;code>SIGTERM&lt;/code> 等&lt;/p>
&lt;p>以下是幾種常見的 Container 執行指令，但分別有一些問題&lt;/p>
&lt;h4 id="1-cmd-npm-start">1. CMD &amp;ldquo;npm&amp;rdquo; &amp;ldquo;start&amp;rdquo;&lt;/h4>
&lt;p>這會遇到兩個問題&lt;/p>
&lt;ol>
&lt;li>透過 npm 啟動 Node.js process，但是 &lt;code>npm 不會正確 pass 所有的系統中斷到 Node.js process 上&lt;/code>&lt;/li>
&lt;li>&lt;code>CMD &amp;quot;cmd&amp;quot; &amp;quot;params&amp;quot; ..&lt;/code> 與 &lt;code>CMD [&amp;quot;cmd&amp;quot;, &amp;quot;params&amp;quot;]&lt;/code> 是不同的，前者是先啟動 shell 再去執行後面的 cmd；而後者則是直接執行 cmd，最直接的差異就是 &lt;code>PID 1 是 shell 還是 cmd&lt;/code>，透過 shell 同樣有可能不會收到全部的系統中斷&lt;/li>
&lt;/ol>
&lt;h4 id="2-cmd-node-indexjs">2. CMD [&amp;ldquo;node&amp;rdquo;, &amp;ldquo;index.js&amp;rdquo;]&lt;/h4>
&lt;p>優化上面的指令，改由直接啟動 node.js 少了 npm 與 shell，這會遇到另一個問題 &lt;code>linux 對於 PID 1 的程序有特別的處理&lt;/code>，因為 PID 1 代表此程序要負責系統的初始化，所以 Kernel 會有額外的處理機制，實際的影響有&lt;/p>
&lt;ol>
&lt;li>一般的程序收到 &lt;code>SIGTERM&lt;/code> 後 Kernel 會有預設的結束處理，但是 &lt;code>PID 1 沒有預設終止處理，也就是收到後沒有主動退出就不會退出&lt;/code>&lt;/li>
&lt;li>如果有 orphan process 會被主動掛載到 PID 1 之下，但一般的 process 不會去處理 orphan process，會留下很多 zombie process&lt;/li>
&lt;/ol>
&lt;p>根據 Node.js Docker 小組建議，不要讓 Node.js 運行在 PID 1 上&lt;/p>
&lt;blockquote>
&lt;p>Node.js was not designed to run as PID 1 which leads to unexpected behaviour when running inside of Docker. For example, a Node.js process running as PID 1 will not respond to SIGINT (CTRL-C) and similar signals&lt;/p>
&lt;/blockquote>
&lt;h4 id="最終解法透過-init-process-再去啟動-nodejs">最終解法：透過 init process 再去啟動 Node.js&lt;/h4>
&lt;p>最後用 dumb-init，這套由 yelp 釋出的啟動 process，會正確將所有的系統中斷都 pass 給所有的 child process，並且在退出時清除所有的 orphan process&lt;/p>
&lt;p>&lt;a class="link" href="https://engineeringblog.yelp.com/2016/01/dumb-init-an-init-for-docker.html" target="_blank" rel="noopener"
>Introducing dumb-init, an init system for Docker containers&lt;/a>&lt;/p>
&lt;p>市面上還有不同的選擇，可以參考此篇 &lt;a class="link" href="https://ahmet.im/blog/minimal-init-process-for-containers/" target="_blank" rel="noopener"
>Choosing an init process for multi-process containers&lt;/a>&lt;/p>
&lt;h2 id="5-正確處理-build-階段使用的機敏資料">5. 正確處理 Build 階段使用的機敏資料&lt;/h2>
&lt;blockquote>
&lt;p>善用 multi stage，讓機敏資料不要外洩在 Image 當中，並使用 mount secret 同步機敏資料&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">RUN --mount&lt;span class="o">=&lt;/span>&lt;span class="nv">type&lt;/span>&lt;span class="o">=&lt;/span>secret,id&lt;span class="o">=&lt;/span>npmrc,target&lt;span class="o">=&lt;/span>/usr/src/app/.npmrc npm ci --only&lt;span class="o">=&lt;/span>production
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/blockquote>
&lt;p>如果有一些機敏資料是在 Building 階段所需要，例如要去 private github 拉 repo 的 .npmrc 等資料，需要被妥善處理，常見的錯誤示範有&lt;/p>
&lt;ol>
&lt;li>hard code 寫死&lt;/li>
&lt;li>採用環境變數，在 docker build 時指定，但如果用 docker history 還是會被發現&lt;/li>
&lt;/ol>
&lt;p>奇怪的是我並沒有在 Docker 文件 &lt;a class="link" href="https://docs.docker.com/storage/bind-mounts/" target="_blank" rel="noopener"
>Use bind mounts&lt;/a> 看到 &amp;ndash;mount type=secret 的說明，但確實有在官方教學看到 &lt;a class="link" href="https://docs.docker.com/develop/develop-images/build_enhancements/" target="_blank" rel="noopener"
>Build images with BuildKit&lt;/a>&lt;/p>
&lt;h2 id="結語">結語&lt;/h2>
&lt;p>最終的產出會長這樣&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --------------&amp;gt; The build image&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">FROM node:latest AS build
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">WORKDIR /usr/src/app
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">COPY package-*.json /usr/src/app/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RUN --mount&lt;span class="o">=&lt;/span>&lt;span class="nv">type&lt;/span>&lt;span class="o">=&lt;/span>secret,id&lt;span class="o">=&lt;/span>npmrc,target&lt;span class="o">=&lt;/span>/usr/src/app/.npmrc npm ci --only&lt;span class="o">=&lt;/span>production
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># --------------&amp;gt; The production image&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">FROM node:lts-alpine
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">RUN apk add dumb-init
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ENV NODE_ENV production
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">USER node
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">WORKDIR /usr/src/app
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">COPY --chown&lt;span class="o">=&lt;/span>node:node --from&lt;span class="o">=&lt;/span>build /usr/src/app/node_modules /usr/src/app/node_modules
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">COPY --chown&lt;span class="o">=&lt;/span>node:node . /usr/src/app
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CMD &lt;span class="o">[&lt;/span>&lt;span class="s2">&amp;#34;dumb-init&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;node&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;server.js&amp;#34;&lt;/span>&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>Coturn Server 架設教學 - on AWS</title><link>https://yuanchieh.page/posts/2020/2020-09-21-coturn-server-%E6%9E%B6%E8%A8%AD%E6%95%99%E5%AD%B8-on-aws/</link><pubDate>Mon, 21 Sep 2020 08:21:40 +0000</pubDate><guid>https://yuanchieh.page/posts/2020/2020-09-21-coturn-server-%E6%9E%B6%E8%A8%AD%E6%95%99%E5%AD%B8-on-aws/</guid><description>&lt;p>公司 P2P 通信採用 WebRTC tech stack，近日希望自建 STUN/TURN Server，決定採用 &lt;a class="link" href="https://github.com/coturn/coturn" target="_blank" rel="noopener"
>Coturn&lt;/a> 這套知名的解決方案，在 AWS 架設過程遇到一些坑，決定分享如何架設，並分享設定檔如何設定與操作&lt;br>
以下包含&lt;/p>
&lt;ol>
&lt;li>Coturn 於 AWS 上的架設與測試&lt;/li>
&lt;li>介紹設定檔內容&lt;/li>
&lt;li>上 Production 的考量&lt;/li>
&lt;li>補充 NAT 與 STUN/TURN 關係&lt;/li>
&lt;/ol>
&lt;p>如果想知道更詳細的協定介紹，請參考&lt;/p>
&lt;ol>
&lt;li>&lt;a class="link" href="https://yuanchieh.page/post/2020-09-22_rfc-5389-stun-%E5%8D%94%E5%AE%9A%E4%BB%8B%E7%B4%B9/" target="_blank" rel="noopener"
>RFC 5398 - STUN&lt;/a>&lt;/li>
&lt;/ol>
&lt;p>如果想要用 Container 架設，可以參考我用 docker-compose 架設的方式 &lt;a class="link" href="https://github.com/sj82516/coturn-with-prometheus-grafana-on-docker" target="_blank" rel="noopener"
>Running Coturn + Promethes + Grafana in Docker&lt;/a>&lt;/p>
&lt;h2 id="coturn-於-aws-上的架設">Coturn 於 AWS 上的架設&lt;/h2>
&lt;p>使用 Ubuntu 18.04 非常簡單，只要以下指令就能啟動 Coturn&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ sudo apt-get -y update
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo apt-get -y install coturn
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>強烈建議使用 &lt;code>Ubuntu 18.04&lt;/code> 而不要用 &lt;code>Amazon Linux 2&lt;/code>，Amazon Linux 2 要自己處理各種套件的相依性，架設過程花了半天還沒架起來&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>用 apt-get install 的話，會被限制版本，如果有其他需求，例如支援除了 SQLite 以外的 DB，或是要安裝 Prometheus，建議從 source code build 起，可以參考另一篇文章&lt;/p>
&lt;/blockquote>
&lt;p>安裝後會有幾個 command 能夠使用&lt;/p>
&lt;ol>
&lt;li>turnserver&lt;br>
啟動 STUN/TURN server instance&lt;/li>
&lt;li>turnadmin&lt;br>
介面管理後台&lt;br>
其餘都是測試用工具&lt;/li>
&lt;li>turnutils_peer&lt;br>
UDP-only echo server，檢測連線使用&lt;/li>
&lt;li>turnutils_stunclient&lt;br>
呼叫 STUN server 並取得回應&lt;/li>
&lt;li>turnutils_uclient&lt;br>
可以模擬多人連線 TURN server 並取得回應&lt;/li>
&lt;/ol>
&lt;p>上一步安裝後預設會自行啟動 Coturn，但為了後續的實驗，先把 turn service 關閉&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ sudo service coturn status
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// 如果有在運行，先關閉
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo service coturn stop
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接著啟動 turnserver&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ sudo turnserver
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>稍微看一下 command line 跳出的訊息，大致說明&lt;/p>
&lt;ol>
&lt;li>file descriptor 上限，這會影響最大連線數，可以透過 &lt;code>$ sudo ulimit -n {number}&lt;/code>去調整&lt;/li>
&lt;li>支援的通訊協定，預設 STUN 支援 UDP / TCP / DTLS，但因為目前沒有指定憑證，所以 DTLS 不支援&lt;/li>
&lt;li>採用的 Database，預設使用 SQLite，主要用來儲存 admin 資訊 / turn 連線資訊等，同時支援 MySQL / Redis / PostgreSQL / MongoDB，可以自由替換；&lt;br>
根據 Spec &lt;code>STUN/TURN Server 處理連線是 State-less&lt;/code>，意即 Database 不是用來儲存連線資料，所以不用擔心會是 bottleneck (如果 Coturn 遵守 Spec 的話)&lt;/li>
&lt;/ol>
&lt;p>看一下有沒有什麼錯誤，cli-password 錯誤可以先忽略&lt;/p>
&lt;h3 id="啟動-turnserver">啟動 turnserver&lt;/h3>
&lt;p>要測試之前，我們需要先設定 AWS security group，開放以下的 port&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">3478: UDP+TCP // TURN Server 接收 request 的 port
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">5394: UDP+TCP // TURN Server 接收 TLS request 的 port
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">49152-65536: UDP+TCP // 實際連線的 Socket Port range
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>以上三個都能夠調整，但就先採用預設&lt;/p>
&lt;p>接著啟動 turnserver&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo turnserver -v --lt-cred-mech --user hello:world --realm &amp;lt;your domain name&amp;gt; --external-ip &amp;lt;your instance public-ip&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>以上的參數代表&lt;/p>
&lt;ol>
&lt;li>&lt;code>-v&lt;/code>: 顯示詳細的 log&lt;/li>
&lt;li>&lt;code>--lt-cred-mech&lt;/code>: 指定為 long term credential，稍後解釋&lt;/li>
&lt;li>&lt;code>--user {username}:{password}&lt;/code>: 搭配 long term credential，指定 username / password&lt;/li>
&lt;li>&lt;code>--realm&lt;/code>: 指定 TURN server 對應的 domain name，提示 client 要採用對應的驗證方式&lt;/li>
&lt;li>&lt;code>--external-ip&lt;/code>: 指定 external ip，在 Coturn 文件寫到，如果是在 AWS EC2 上架設 external-ip 只要指定 public ic&lt;/li>
&lt;/ol>
&lt;p>記得要去將綁定 domain name A record 指向 AWS instance&lt;/p>
&lt;p>接著，有幾種測試方法&lt;/p>
&lt;h4 id="1-使用-coturn-自帶的-test-tool">1. 使用 Coturn 自帶的 test tool&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ turnutils_uclient -T &amp;lt;server ip&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ turnutils_stunclient &amp;lt;server ip&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>第一個會嘗試傳送封包，可以看 packet 的 loss rate 是否為 0 /&lt;br>
第二個會回傳主機 public ip (如果前面沒有 NAT 的話)，也就是 STUN 最主要的功用&lt;/p>
&lt;h4 id="2-用瀏覽器開啟-webrtc-samples-trickle-ice">2. 用瀏覽器開啟 WebRTC samples Trickle ICE&lt;/h4>
&lt;p>&lt;img src="https://yuanchieh.page/post/img/20200922/trickle-ice.png"
loading="lazy"
>&lt;br>
輸入 server domain 時記得要加 &lt;code>turn:{domain name}&lt;/code>，就可以成功拿到 STUN (srflx) / TURN (relay) 的紀錄&lt;/p>
&lt;p>測試了一下，Chrome / Firefox 不支援 no auth 設定，Chrome 不支援 ip based 的 server&lt;/p>
&lt;p>這樣就完成第一步的設定與測試，接著看 Coturn 的完整介紹與設定&lt;/p>
&lt;h2 id="設定檔">設定檔&lt;/h2>
&lt;p>設定檔的預設路徑為 &lt;code>/etc/turnserver.conf&lt;/code>，也就是等等會修改的文件，可以放在其他地方用 cmd 指定&lt;br>
也可以從網路上看到官方的預設設定檔 &lt;a class="link" href="https://raw.githubusercontent.com/coturn/coturn/master/examples/etc/turnserver.conf" target="_blank" rel="noopener"
># Coturn TURN SERVER configuration file&lt;/a>&lt;/p>
&lt;h3 id="驗證">驗證&lt;/h3>
&lt;p>STUN 的費用很便宜，只有簡單的 request / response，但是 TURN 就非常貴，因為要回放(Relay) P2P 的 media stream，所以 Bandwidth 相當驚人，這時候就需要加上帳號密碼的檢查&lt;/p>
&lt;p>TURN 支援兩種模式，建議是兩者選其中一者&lt;/p>
&lt;h4 id="long-term-credential">long term credential&lt;/h4>
&lt;p>長期憑證屬於靜態類型，也就是 Client / Server 共用固定的帳號密碼，例如上述的 hello:world&lt;br>
在設定檔中&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">lt-cred-mech
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">user&lt;/span>&lt;span class="o">=&lt;/span>hello:world
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">user&lt;/span>&lt;span class="o">=&lt;/span>hello2:world2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">....
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="short-term-credential">short term credential&lt;/h4>
&lt;p>如果希望發給 Client 短期的憑證，或是希望多一層授權的流程例如從 API Server 給予等等，可以使用短期憑證&lt;/p>
&lt;p>TURN 實作的方式是 Client / Server 共享一個固定的 secret key，接著使用 &lt;code>HMAC_SHA1 將 username hashed&lt;/code>，username 的前半段是 unix timestamp&lt;br>
所以 TURN server 收到後，從 username 可以看出過期時間，透過 HMAC_SHA1 可以確保是由合法的 Client 所送出&lt;br>
設定檔寫法&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">use-auth-secret
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">static-auth-secret&lt;span class="o">={&lt;/span>secret&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Nodejs 版本的產生規則如下，參考自 &lt;a class="link" href="https://stackoverflow.com/questions/35766382/coturn-how-to-use-turn-rest-api/35767224#35767224" target="_blank" rel="noopener"
>CoTURN: How to use TURN REST API?&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">var&lt;/span> &lt;span class="nx">crypto&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">require&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;crypto&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// name 隨便填沒有關係
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">function&lt;/span> &lt;span class="nx">getTURNCredentials&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">secret&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">var&lt;/span> &lt;span class="nx">unixTimeStamp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">parseInt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">Date&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">now&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="mi">1000&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">24&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">3600&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// this credential would be valid for the next 24 hours
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">username&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nx">unixTimeStamp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">name&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="nx">join&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;:&amp;#39;&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">password&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">hmac&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">crypto&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">createHmac&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;sha1&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">secret&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">hmac&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">setEncoding&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;base64&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">hmac&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">username&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">hmac&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">end&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">password&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">hmac&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">read&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">username&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">username&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">password&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="nx">password&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="網路設定">網路設定&lt;/h3>
&lt;p>網路設定就放在一塊看&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">external-ip&lt;span class="o">=&lt;/span>&amp;lt;public ip&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">fingerprint
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">realm&lt;/span>&lt;span class="o">=&lt;/span>turn.yuanchieh.page
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>以上是必須設定的參數&lt;/p>
&lt;ol>
&lt;li>external-ip:&lt;br>
TURN server 的 public ip，看文件完整的設定是 &lt;code>external-ip=&amp;lt;public ip&amp;gt;/&amp;lt;private ip&amp;gt;&lt;/code>，但因為在 AWS 上 EC2 處於 NAT 之後，所以只能放 public ip&lt;/li>
&lt;li>fingerprint:&lt;br>
主要是 TURN Server 用來區分 packet，後續的 Spec 會有更詳細介紹&lt;/li>
&lt;li>realm:&lt;br>
設定為自己指向 TURN Server 的 domain name，文件表示 TURN Server 可以指定多個 realm，每個 realm 有各自的 user 權限管理，Client 表明所屬的 realm 就能用對應的 user 檢查&lt;/li>
&lt;/ol>
&lt;p>其餘還有非常多的設定，例如說&lt;/p>
&lt;ol>
&lt;li>是否要開放 UDP / TCP / DTLS / stun-only&lt;/li>
&lt;li>設定不同的 port / port ranage&lt;/li>
&lt;li>指定的 DB / Log 等等&lt;/li>
&lt;li>每次連線 session 的時長 / 每個 user 的連線 quota 等等 &lt;br>
這些細部的設定可以在慢慢看或是保留預設即可&lt;/li>
&lt;/ol>
&lt;p>以下是我測試過成功的設定檔&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">external-ip&lt;span class="o">=&lt;/span>52.72.33.185
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">verbose
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">fingerprint
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">use-auth-secret
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">static-auth-secret&lt;span class="o">=&lt;/span>north
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">realm&lt;/span>&lt;span class="o">=&lt;/span>turn.yuanchieh.page
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>啟動 turnserver 時透過 &lt;code>-c&lt;/code> 指定 turnserver.conf 的位置，完成後建議在使用測試工具測試過&lt;/p>
&lt;h2 id="sample-code">Sample Code&lt;/h2>
&lt;p>為了更方便測試 TURN Server，自己寫了一個 Sample Code &lt;a class="link" href="https://github.com/sj82516/webrtc-turn-server-test" target="_blank" rel="noopener"
>Connection through self-hosted TURN server&lt;/a>，或是直接看 Demo Page &lt;a class="link" href="https://webrtc-turn-server-test.vercel.app/" target="_blank" rel="noopener"
>https://webrtc-turn-server-test.vercel.app/&lt;/a>，輸入對應的帳號密碼，會主動生成對應的 iceServers&lt;/p>
&lt;h2 id="go-to-production">Go To Production&lt;/h2>
&lt;p>準備上正式環境時，還有監控以及可用性的調整&lt;/p>
&lt;h3 id="監控">監控&lt;/h3>
&lt;p>2020/12/04更新：目前 4.5.2 可以支援 &lt;code>prometheus&lt;/code> 囉，可是只有支援 Debian，其他平台尚未支援，另外要注意直接用 &lt;code>apt-get install coturn 版本目前是不支援 prometheus，需要自己手動編譯喔&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">Version 4.5.2 &lt;span class="s1">&amp;#39;dan Eider&amp;#39;&lt;/span>:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - fix null pointer dereference in &lt;span class="k">case&lt;/span> of out of memory. &lt;span class="o">(&lt;/span>thanks to Thomas Moeller &lt;span class="k">for&lt;/span> the report&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> - merge PR &lt;span class="c1">#517 (by wolmi)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> * add prometheus metrics
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>Warning: 撰文時開啟 prometheus 會有記憶體問題，建議先不要使用喔，詳見 github issue &lt;a class="link" href="https://github.com/coturn/coturn/issues/666" target="_blank" rel="noopener"
>https://github.com/coturn/coturn/issues/666&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;del>看到文件的範例以及設定檔支援 &lt;code>prometheus&lt;/code> 這套開源的監控工具，但可惜實測下來暫時無法使用(4.5.1.2)，雖然說有相關的 branch 已經 merged 但是 Issue 還是開著 &lt;a class="link" href="https://github.com/coturn/coturn/issues/474" target="_blank" rel="noopener"
>support export metrics to prometheus #474&lt;/a>&lt;/del>&lt;/p>
&lt;h3 id="可用性">可用性&lt;/h3>
&lt;p>如果只有單台 TURN server 掛掉導致服務中斷就很慘了，官方有幾個可用性/Load Balance 作法&lt;/p>
&lt;ol>
&lt;li>TCP Level LB Proxy:&lt;br>
需注意如果有使用 TURN 功能，必須確保同一個 Client 持續連到同一台 TURN Server，否則普通的 TCP LB 即可&lt;/li>
&lt;li>DNS:&lt;br>
透過 DNS Round-Robin 紀錄，讓 Client 連到對應的 TURN Server&lt;/li>
&lt;li>內建的 ALTERNATE-SERVER:&lt;br>
需要在所有的 TURN Server 之前建一台 LB，這台 LB 按照流量回給 Client ALTERNATE-SERVER 的錯誤，Client 就會按照指定的 Server 去走，達到 LB 的效果&lt;/li>
&lt;/ol>
&lt;p>看來看去，採用 DNS 比較方便，AWS Route53 支援定期檢查 Server 狀態，只會回傳健康的 Server，同時能採用 Latency based 或是 Region based 的 DNS 紀錄，讓全球部署更加方便&lt;/p>
&lt;h2 id="nat-介紹與-stunturn-使用">NAT 介紹與 STUN/TURN 使用&lt;/h2>
&lt;p>先前有提到因為 NAT 關係，所以要建立 P2P 連線會需要 STUN Server 的幫助，但有一種 NAT 是必須透過 TURN Server，以下解釋這部分的狀況&lt;/p>
&lt;p>&lt;a class="link" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2" target="_blank" rel="noopener"
>Wiki NAT 網路位址轉換&lt;/a>&lt;br>
&lt;a class="link" href="https://blog.csdn.net/eydwyz/article/details/87364157" target="_blank" rel="noopener"
>NAT的四种类型&lt;/a>&lt;/p>
&lt;p>簡單整理上面文中的重點&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">ClientA &lt;span class="o">(&lt;/span>192.168.9.1:3000&lt;span class="o">)&lt;/span> ---&amp;gt; NAT &lt;span class="o">(&lt;/span>8.8.8.8:800&lt;span class="o">)&lt;/span> ---&amp;gt; Server1 &lt;span class="o">(&lt;/span>1.1.1.1:1000&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>ClientA 預先與 Server1 取得連線，此時假設 Server2 (2.2.2.2) 想要從 (8.8.8.8:800) 送資料給 ClientB&lt;/p>
&lt;ol>
&lt;li>完全圓錐型NAT &lt;br>
允許&lt;/li>
&lt;li>受限圓錐型NAT &lt;br>
必須 ClientA 也送過請求給 Server2 (2.2.2.2)才可以&lt;/li>
&lt;li>埠受限圓錐型NAT &lt;br>
必須 ClientA 也送過請求給 Server2 (2.2.2.2:1000)才可以，相較於上者 Port 必須固定&lt;/li>
&lt;li>對稱NAT&lt;br>
不允許&lt;/li>
&lt;/ol>
&lt;p>所以在 WebRTC 下，如果 Client 在完全圓錐型NAT，任一方發請連線都可以；&lt;br>
如果是在二、三種，則 Client 必須雙方同時發送請求，才符合 NAT 轉發條件；&lt;br>
第四種則不允許直接的 P2P&lt;/p></description></item><item><title>Vault 教學-集中化管理機敏資料(上)</title><link>https://yuanchieh.page/posts/2020/2020-04-23-vault-%E6%95%99%E5%AD%B8-%E9%9B%86%E4%B8%AD%E5%8C%96%E7%AE%A1%E7%90%86%E6%A9%9F%E6%95%8F%E8%B3%87%E6%96%99%E4%B8%8A/</link><pubDate>Thu, 23 Apr 2020 20:21:40 +0000</pubDate><guid>https://yuanchieh.page/posts/2020/2020-04-23-vault-%E6%95%99%E5%AD%B8-%E9%9B%86%E4%B8%AD%E5%8C%96%E7%AE%A1%E7%90%86%E6%A9%9F%E6%95%8F%E8%B3%87%E6%96%99%E4%B8%8A/</guid><description>&lt;div class="video-wrapper">
&lt;iframe loading="lazy"
src="https://www.youtube.com/embed/VYfl-DpZ5wM"
allowfullscreen
title="YouTube Video"
>
&lt;/iframe>
&lt;/div>
&lt;p>內容摘錄自影片介紹，要討論 Vault 的功能之前，先退一步回來看最一般的機敏資料的定義與管理方式&lt;/p>
&lt;p>機敏資料主要分成 &lt;code>驗證(Authentication)&lt;/code> 與 &lt;code>授權(Authorization)&lt;/code>，一者表明身份一者決定操作的權限，可能是 DB 的權限 / 第三方服務的 API Token / 用來加解密的對稱金鑰等等，這些資料可能被放在原始碼當中 / config 文件 / 環境變數 / 版本控制等等四散各地，之前 Github 有提出許多開發者都誤上傳機敏資料；&lt;br>
另一方面時間一久沒有人知道到底發出去哪些 key 又或是誰有在用，糟糕的是可能一組 key 有多個人使用&lt;/p>
&lt;p>Vault 提出三個層級的解決方案&lt;br>
&lt;strong>&lt;code>1. 集中化管理&lt;/code>&lt;/strong> &lt;br>
搭建 Vault Server 集中管理所有的機敏資料，在 Vault Server 中確保所有的機敏資料都是&lt;code>被加密儲存&lt;/code>，同時 Client 來跟 Server 要機敏資料時&lt;code>傳輸過程也是加密的&lt;/code>，安全性大幅提升；&lt;br>
且有 Vault 管理，可以定期 Rotate，並隨時查看目前的機敏資料使用狀況&lt;br>
&lt;strong>&lt;code>2.動態生成&lt;/code>&lt;/strong> &lt;br>
透過動態生成方式，每一個 Client 來要即使權限需求相同，也動態生成不同的 key，如果有異常操作，就能很清楚是哪一個 Client 有問題，接著直接 revoke 掉就行了；&lt;br>
如果大家都共用一把 key，就查不出是誰也不能直接 revoke，造成安全上的漏洞&lt;br>
&lt;strong>&lt;code>3.Encrpyt as Service&lt;/code>&lt;/strong>&lt;br>
API Server 設計時，我們常需要加解密資料，所以會需要金鑰與實作加解密演算法，但是一方面金鑰外流到 API Server 上多一層風險，再者如果加解密演算法有漏洞又是另一個風險；&lt;br>
所以 Vault Server 本身也提供加解密 API，讓金鑰與演算法的保障都留在 Vault Server 上，大幅降低風險。&lt;/p>
&lt;p>架構上，Vault 拆成幾個模組增加相容性 &lt;br>
&lt;img src="https://yuanchieh.page/post/img/20200423/vault.png"
loading="lazy"
>&lt;/p>
&lt;ol>
&lt;li>Authentication&lt;br>
基於人員的驗證，可以透過第三方的架構如 AWS/LDAP，或是K8S&lt;/li>
&lt;li>Audit &lt;br>
將所有的操作都記錄下來，可以存放在 system logs 或是其他儲存方式&lt;/li>
&lt;li>Secret&lt;br>
機敏資料的型態，可能是 Key-Value，也可能是第三方服務如 Database / AWS 等&lt;/li>
&lt;li>Storage&lt;br>
機敏資料的儲放位置&lt;/li>
&lt;/ol>
&lt;p>以下教學將初步探索 Vault 功能為主，只適用於學習與測試環境使用!&lt;br>
下一篇實作篇，以 AWS 為主，動態 Launch API Server 時主動索取機敏資料，被配與動態 MongoDB 金鑰與 AWS Role&lt;/p>
&lt;h2 id="vault-初探">Vault 初探&lt;/h2>
&lt;p>&lt;a class="link" href="https://learn.hashicorp.com/vault/getting-started/install" target="_blank" rel="noopener"
>Vault 官方教學&lt;/a> 是一個互動式的教學，蠻簡單明瞭的，以下是整理的筆記，僅適用於學習，完全不建議用在正式環境!&lt;/p>
&lt;p>先到 &lt;a class="link" href="https://www.vaultproject.io/downloads" target="_blank" rel="noopener"
>官方載點&lt;/a>下載並安裝，設定好路徑之後可以安裝 auto complete &lt;code>$vault -autocomplete-install&lt;/code>，vault 會偵測 shell 安裝對應的插件&lt;/p>
&lt;h3 id="啟動測試環境的-vault-server">啟動測試環境的 Vault server&lt;/h3>
&lt;p>&lt;code>$ vault server -dev&lt;/code> 接著會在 terminal 打印出 Root Token: 的字樣，此時 vault server 會跑在前景；&lt;br>
開啟另一個 terminal tab，將其輸出至環境變數等等會使用上 &lt;code>export VAULT_DEV_ROOT_TOKEN_ID=&amp;quot;{替換 Root Token}&amp;quot;&lt;/code>，接著指定 vault server url &lt;code>$export VAULT_ADDR='http://127.0.0.1:8200'&lt;/code>；&lt;br>
透過 &lt;code>$ vault status&lt;/code> 檢查是否指定正確&lt;/p>
&lt;h3 id="取得新增更新刪除-secret">取得/新增/更新/刪除 secret&lt;/h3>
&lt;p>先前提到 Secret 有很多種，從最簡單的 key value 開始，Vault 通過以下指令設定&lt;/p>
&lt;ol>
&lt;li>&lt;code>vault kv put secret/{path} {key}={vaule} {key2}={value2}&lt;/code>&lt;/li>
&lt;li>&lt;code>vault kv get -format=json secret/{path}&lt;/code>&lt;br>
format 是選擇性回指定回傳格式&lt;/li>
&lt;li>&lt;code>vault kv delete secret/{path}&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>可以把 Vault Server 儲存密碼的方式想成 RESTful API Server，指定資源的路徑，採用最長匹配方式，&lt;code>secret&lt;/code> 是預設的前綴，後面的path 用 / 分隔，接著的 kv 可以設定多組，put 同時代表新增與更新；&lt;/p>
&lt;h3 id="啟用-secret-並設定-path">啟用 Secret 並設定 path&lt;/h3>
&lt;p>預設用 dev 啟動後 &lt;code>secret/&lt;/code> 路徑會對應到 KV 儲存方式，可以透過 &lt;code>$vault secrets list&lt;/code> 查看，接著如果我們想要自訂其他的 Secret，或是指定新的路徑儲放 KV，可以透過 &lt;code>$vault secrets enable -path={path} {secret engine}&lt;/code> 例如 &lt;code>$vault secrets enable -path=kv kv&lt;/code> 就能指定 kv/ 為新的 key-value 儲存路徑&lt;/p>
&lt;p>接著下 &lt;code>$vault kv put kv/hello foo=bar&lt;/code> 可以得到相同的結果，透過 &lt;code>$vault secrets list&lt;/code> 可以看出來多了一組設定&lt;/p>
&lt;p>如果不要用了，可以透過 &lt;code>$vault secrets disable {path}/&lt;/code> 如 &lt;code>$vault secrets disable kv/&lt;/code> 刪除，注意底下儲存的密碼也都會一並消失&lt;/p>
&lt;h3 id="啟動-aws-secret-engine-取得動態-accesskey--accesssecret">啟動 AWS Secret Engine 取得動態 AccessKey / AccessSecret&lt;/h3>
&lt;p>先前提到 Vault 一大特色是支援多種 Secret，而且 Secret 可以是動態生成的，每一個 Client 來索取都能要到獨立的 Secret&lt;/p>
&lt;p>透過 aws secret engine，可以指定 Role 與權限並給予動態 secret，首先讓我們啟動 secret &lt;code>$vault secrets enable -path=aws aws&lt;/code>，接著設定 aws 帳號&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">$ vault write aws/config/root &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> &lt;span class="nv">access_key&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">AWS&lt;/span>&lt;span class="p"> Access Key&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> &lt;span class="nv">secret_key&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">AWS&lt;/span>&lt;span class="p"> Secret key&lt;/span>&lt;span class="si">}&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> &lt;span class="nv">region&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="si">${&lt;/span>&lt;span class="nv">AWS&lt;/span>&lt;span class="p"> Region&lt;/span>&lt;span class="si">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>絕對不建議在生產環境如此使用，因為 shell command 會被記錄在 log 中&lt;/p>
&lt;/blockquote>
&lt;p>後續的操作，Vault 就會用這組帳密去管理 IAM&lt;/p>
&lt;p>接著創建角色&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">$ vault write aws/roles/my-role &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> &lt;span class="nv">credential_type&lt;/span>&lt;span class="o">=&lt;/span>iam_user &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> &lt;span class="nv">policy_document&lt;/span>&lt;span class="o">=&lt;/span>-&lt;span class="s">&amp;lt;&amp;lt;EOF
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">{
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> &amp;#34;Statement&amp;#34;: [
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> &amp;#34;Sid&amp;#34;: &amp;#34;Stmt1426528957000&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> &amp;#34;Action&amp;#34;: [
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> &amp;#34;ec2:*&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> ],
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> &amp;#34;Resource&amp;#34;: [
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> &amp;#34;*&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> ]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s"> ]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">}
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="s">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>這裡給予了 ec2 全部的權限&lt;/p>
&lt;p>接著要產生 Secret 通過 &lt;code>$vault read aws/creds/my-role&lt;/code>，此時就會回傳一組新的 role，每次呼叫都會回傳獨立的 Secret (為什麼用 read 代表創建動作就不確定設計的原理了 :thinking_face)，從 IAM Console 可以看到被創建的用戶
&lt;img src="https://yuanchieh.page/post/img/20200423/vault_aws_user.png"
loading="lazy"
>&lt;/p>
&lt;p>如果要 revoke 的話，通過 &lt;code>$vault lease revoke aws/creds/my-role/{lease id}&lt;/code> 即可&lt;/p>
&lt;p>剛剛想要查找有沒有指令可以條列出所有的 credentials，但看來是沒有這項指令，如果當初沒有記得 lease id 的話，就要去 IAM Console 手動刪除了&lt;/p>
&lt;p>所有的指令可以從這邊看到 &lt;a class="link" href="https://www.vaultproject.io/api-docs/secret/aws" target="_blank" rel="noopener"
>AWS Secret 文件&lt;/a>，或是用 &lt;code>$vault path-help aws&lt;/code> 查看，path-help 可以指定不同的路徑層次，例如 &lt;code>$vault path-help aws/config/lease&lt;/code>&lt;/p>
&lt;h3 id="authentication--authorization">Authentication &amp;amp; Authorization&lt;/h3>
&lt;p>現在我們知道要如何建立與管理金鑰，但重點回到&lt;code>誰能來要金鑰以及權限劃分&lt;/code>，Authentication 部分 Vault 可以用 token / AppRule / Github / AWS IAM / LDAP 等等，Authorization 部分可以制定 Policy，限縮用戶能夠操作的 Secret 權限&lt;/p>
&lt;h4 id="token">Token&lt;/h4>
&lt;p>Token 驗證機制是 Vault 核心、不能被關閉的驗證功能，像我們一開始啟動 Vault Server 後會產生一個 root token，接著會用 root token 去制定 Policy，並產生多組 Token，文件提到如果&lt;code>設定完就應該 revoke root token&lt;/code>，最好是有 root token 時大家一起盯著螢幕操作後就 revoke，後續有需要可以在動態生成&lt;/p>
&lt;ol>
&lt;li>$vault operator init&lt;/li>
&lt;li>$vault operator generate-root&lt;/li>
&lt;li>用 root token 生成其他 root token&lt;/li>
&lt;/ol>
&lt;p>在 Vault 中，Token 管理是階層化的，用母 Token 去生成的 Token 會自動變成子 Token，為了管理方便，如果母 Token 被 Revoke 那麼以下&lt;code>所有的子 Token 會全數被 Revoke&lt;/code>，如果希望 Token 不受母 Token 影響，可以用設定為 Orphan Token，跳脫階層獨立管理&lt;/p>
&lt;p>除了 Root Token，其餘的 Token 都有 TTL，TTL 設定有幾個地方&lt;/p>
&lt;ol>
&lt;li>Vault Server 啟動時的 Config&lt;/li>
&lt;li>透過 mount tuning 去更改&lt;/li>
&lt;li>根據母 Token 的Policy&lt;/li>
&lt;/ol>
&lt;p>在有些長駐的程式中，需要長時間持有 Token 可以設定為 &lt;code>Periodic&lt;/code>，指定更新週期只要在這期間內去 renew 就能繼續使用 Token，同時可以指定 TTL 或是設為永不失效，等 TTL 到了會自動 revoke&lt;/p>
&lt;p>Token 建立後會回傳 id / accessor / policy 等資訊，&lt;code>accessor&lt;/code> 可以用來操作 token 相關的指令例如 renew / revoke / 反查 token id 等等，不太確定為什麼不直接用 token id 而是要多產生另一組 accessor 代號，但目前看到要條列出所有 token 只能透過列出 accessors 再去反查 token&lt;/p>
&lt;p>以上的 Token 是指 &lt;code>Service Token&lt;/code>，也就是預設最常使用的 Token 形式；另外還有 Batch Token 用在 Vault 操作上，暫時沒有看到用處就先略過&lt;/p>
&lt;p>接著實際操作看看&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">// 透過 root 生成的 token，ttl 預設為無過期
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ vault token create
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">----- 開啟另一個 shell，試著用剛剛的 token 登入
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ &lt;span class="nb">export&lt;/span> &lt;span class="nv">VAULT_ADDR&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;http://127.0.0.1:8200&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ vault login &lt;span class="o">{&lt;/span>token&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">------
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// 刪除剛才的 token
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ vault token revoke &lt;span class="o">{&lt;/span>token&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// 新增一個 ttl 為 1h 的 token
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ vault token create -ttl&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;1h&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其他的部分，覺得透過 api 下指令比較方便，東西也比較全面，可以參考&lt;a class="link" href="https://www.vaultproject.io/api/auth/token" target="_blank" rel="noopener"
>文件&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">// 查看所有的 accessors
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ curl &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --header &lt;span class="s2">&amp;#34;X-Vault-Token: {token}&amp;#34;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --request LIST &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> http://127.0.0.1:8200/v1/auth/token/accessors
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// 查看各別 accessor
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ curl &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --header &lt;span class="s2">&amp;#34;X-Vault-Token: {token}&amp;#34;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --request POST &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --data &lt;span class="s1">&amp;#39;{&amp;#34;accessor&amp;#34;: &amp;#34;{accessor id}&amp;#34;}&amp;#39;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> http://127.0.0.1:8200/v1/auth/token/lookup-self
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// 透過 accessor revoke token
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ curl &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --header &lt;span class="s2">&amp;#34;X-Vault-Token: {token}&amp;#34;&lt;/span> &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --request POST &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --data &lt;span class="s1">&amp;#39;{&amp;#34;accessor&amp;#34;: &amp;#34;{accessor token}&amp;#34;}&amp;#39;&lt;/span>&lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> http://127.0.0.1:8200/v1/auth/token/revoke-accessor
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="設定-policy">設定 Policy&lt;/h2>
&lt;p>接著就是設定 Policy 部分，限制不同 Token 能夠操作 Secret 的權限，Vault 撰寫 policy 的格式是採用 hcl，也就是 HashiCorp 自己內部的 Config 描述語言，在路徑下建立檔案 &lt;code>my-policy.hcl&lt;/code> 並貼上以下內容&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">path &lt;span class="s2">&amp;#34;kv/foo&amp;#34;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">capabilities&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="s2">&amp;#34;create&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;update&amp;#34;&lt;/span> &lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">path &lt;span class="s2">&amp;#34;secret/data/foo&amp;#34;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">capabilities&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">[&lt;/span> &lt;span class="s2">&amp;#34;create&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;update&amp;#34;&lt;/span> &lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>上述文件的意思是這個 Policy 只能操作 secret/foo 的新&amp;amp;更新，其他的操作都一率被禁止，&lt;code>/data/&lt;/code> 指的是預設 Key Value 的 Secret 路徑，如果是另外啟動的如 &lt;code>$vault secrets enable -path=kv kv&lt;/code>，則可以不用加 /data 變成 &lt;code>kv/foo&lt;/code> 即可&lt;/p>
&lt;p>接著實際操作&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">$ vault policy write my-policy my-policy.hcl
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ vault token create -policy&lt;span class="o">=&lt;/span>my-policy
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看到 token 的 policy 窩了自定義的 my-policy&lt;/p>
&lt;p>接著開另一個 shell 登入&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">$ vault login &lt;span class="o">{&lt;/span>token&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ vault kv put secret/foo &lt;span class="nv">bar&lt;/span>&lt;span class="o">=&lt;/span>baz
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// permission denied
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ vault kv &lt;span class="nb">read&lt;/span> secret/foo
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ vault kv put secret/foo/bar &lt;span class="nv">bar&lt;/span>&lt;span class="o">=&lt;/span>baz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>後來發現 $vault login 會影響所有的 shell，這點在測試要稍加留意&lt;/p>
&lt;p>Vault Policy 設定可以很彈性，主要有幾項關鍵字&lt;/p>
&lt;h4 id="1-path">1. path&lt;/h4>
&lt;p>路徑選擇，可以用 &lt;code>*&lt;/code> 代表以下所有路徑 / &lt;code>+&lt;/code> 代表此路徑匹配任何字元等方式，如果有多組 path，Vault 採取最長匹配的原則&lt;/p>
&lt;h4 id="2-capabilities">2. capabilities&lt;/h4>
&lt;p>權限選擇，有 &lt;code>[read, create, update, delete, list, sudo, deny]&lt;/code>，文件提到 Vault 沒有很仔細區分 create/update 的使用場景，所以要給就一起給；&lt;br>
sudo 指的是受 root 保護的權限 / deny 是禁止任何操作包含 sudo 也不行&lt;/p>
&lt;h4 id="3-allowed_parameters--denied_parameters--required_parameters">3. allowed_parameters &amp;amp; denied_parameters &amp;amp; required_parameters&lt;/h4>
&lt;p>針對參數的設定，可以條列允許/不允許/必備的參數，如果沒有特別設定，則代表不受任何限制&lt;/p>
&lt;h4 id="4-min_wrapping_ttl--max_wrapping_ttl">4. min_wrapping_ttl &amp;amp; max_wrapping_ttl&lt;/h4>
&lt;p>產生子 Token 的最長與最短 TTL&lt;/p>
&lt;p>以下是綜合範例&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">path &lt;span class="s2">&amp;#34;secret/foo&amp;#34;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">capabilities&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">[&lt;/span>&lt;span class="s2">&amp;#34;create&amp;#34;&lt;/span>&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">allowed_parameters&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;foo&amp;#34;&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;bar&amp;#34;&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">[&lt;/span>&lt;span class="s2">&amp;#34;zip&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;zap&amp;#34;&lt;/span>&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">min_wrapping_ttl&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;1s&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">max_wrapping_ttl&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;90s&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">path &lt;span class="s2">&amp;#34;secret/bar/*&amp;#34;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">capabilities&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">[&lt;/span>&lt;span class="s2">&amp;#34;create&amp;#34;&lt;/span>&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">required_parameters&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">[&lt;/span>&lt;span class="s2">&amp;#34;bar&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;baz&amp;#34;&lt;/span>&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">path &lt;span class="s2">&amp;#34;secret/baz/+/data-*&amp;#34;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">capabilities&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">[&lt;/span>&lt;span class="s2">&amp;#34;create&amp;#34;&lt;/span>&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nv">denied_parameters&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;deny-*&amp;#34;&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>針對 secret/foo，在創建時只允許參數 foo / bar，其中 foo 的 value 不受限，但是 bar 只能是 zip 或是 zap&lt;/p>
&lt;p>第二條是指 secret/bar 底下的任意路徑適用，包含 secret/bar/baz 和 secret/bar/baz/foo&amp;hellip;. 等等，並且必須包含 bar, baz 這兩個參數&lt;/p>
&lt;p>第三條是路徑會匹配如 secret/baz/foo/data-bar，且不允許 deny- 開頭的 key&lt;/p>
&lt;h3 id="多重-policy-與衝突">多重 Policy 與衝突&lt;/h3>
&lt;p>在 Token 創建時可以同時綁定多組 Policy，不免讓人好奇如果兩組 Policy 對同一路徑產生衝突時的狀況，實測發現是 capacities 相同路徑下會給予最綜合的權限，而不是按照順序覆蓋之類的&lt;/p>
&lt;p>可以用 &lt;code>$vault token capabilities {token} {path}&lt;/code> 查詢&lt;/p>
&lt;h3 id="改變-policy">改變 Policy&lt;/h3>
&lt;p>當改變 Policy 時，原本已經建立好的 Token 不會動態套用，需要刪除重建，而新增/更新 Policy 的方式用 &lt;code>$ vault policy write {policy_name} my-policy.hcl&lt;/code>即可&lt;/p>
&lt;h2 id="統整">統整&lt;/h2>
&lt;p>僅僅介紹基本功能就花了不少篇幅，涵蓋了基本的 Secrets / Auth 的功能介紹與操作&lt;/p>
&lt;ol>
&lt;li>啟動 dev server，關掉資料則全部消失&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">$ vault server --dev
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol start="2">
&lt;li>登入與設定路徑&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">$ vault login &lt;span class="o">{&lt;/span>token&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ &lt;span class="nb">export&lt;/span> &lt;span class="nv">VAULT_ADDR&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;http://127.0.0.1:8200&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol start="3">
&lt;li>Secret Engine 是與路徑匹配，secret/data 是預設 Key Store Secret Engine，可以另外開啟新的路徑&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">$ vault secrets &lt;span class="nb">enable&lt;/span> -path&lt;span class="o">=&lt;/span>kv kv
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// 條列
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ vault secrets list -detailed
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ vault secrets disable &lt;span class="o">{&lt;/span>path&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol start="4">
&lt;li>新增&amp;amp;更新/取得／刪除 Token&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">$ vault kv put kv/foo &lt;span class="nv">foo&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;123&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ vault kv get kv/foo
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ vault kv delete kv/foo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol start="5">
&lt;li>Authentication&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">$ vault token create -ttl&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;1h&amp;#34;&lt;/span> -policy&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;my_policy&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ vault token revoke &lt;span class="o">{&lt;/span>token id&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol start="6">
&lt;li>Authorization&lt;br>
另外用 hcl 檔儲存 Policy，並匯入設定中&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">$ vault policy write my-policy my-policy.hcl
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ vault token capabilities &lt;span class="o">{&lt;/span>token&lt;span class="o">}&lt;/span> &lt;span class="o">{&lt;/span>path&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ vault policy &lt;span class="nb">read&lt;/span> my-policy
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ vault policy list
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ vault policy delete my-policy
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>想不到初步介紹就花這麼大的篇幅，下一篇要實作結合 AWS 與搭配 API Server 的流程&lt;/p></description></item><item><title>Packer教學-打造 Image與實際使用經驗</title><link>https://yuanchieh.page/posts/2020/2020-04-15-packer%E6%95%99%E5%AD%B8-%E6%89%93%E9%80%A0-image%E8%88%87%E5%AF%A6%E9%9A%9B%E4%BD%BF%E7%94%A8%E7%B6%93%E9%A9%97/</link><pubDate>Wed, 15 Apr 2020 02:21:40 +0000</pubDate><guid>https://yuanchieh.page/posts/2020/2020-04-15-packer%E6%95%99%E5%AD%B8-%E6%89%93%E9%80%A0-image%E8%88%87%E5%AF%A6%E9%9A%9B%E4%BD%BF%E7%94%A8%E7%B6%93%E9%A9%97/</guid><description>&lt;p>當我們在利用 Vagrant 建立開發環境，或是雲端上準備部署時，都需要用 VM 執行指定的 Image，準備好環境後開始執行應用程式，但是管理 Image 是一件有點麻煩的事，尤其是要記錄每個步驟到底做過了什麼，又或是要整合入持續部署 CD 的環節都不這麼友善&lt;/p>
&lt;p>Packer 用 json 檔指定基礎 Image / Provision 步驟 / 指定平台打造對應的 Image，例如可以同時針對 AWS / DigitalOcean / vmware 等不同平台建立，透過 command line 就可以建立 Image&lt;/p>
&lt;p>以下教學專注在 AWS 的 Image 建立上，並分享實際使用經驗&lt;/p>
&lt;p>Packer 在建立 AWS Image 時會需要開機器，自動上傳的 AMI 並關閉機器，Packer 開立的機器型別時 &lt;code>t2.micro&lt;/code> 有免費的額度，但如果超過可能會有額外的一點點費用，取決於 build image 的次數與時間；&lt;br>
另外 AWS AMI 儲存於 S3，也會有額外的成本，Packer 只負責建立 Image，後續的管理要自己處理&lt;/p>
&lt;p>之前在公司建立 Image 也是要先開新機器，動手處理完壓成 Image，缺點是整個操作步驟是不透明，雖然可以翻 bash_history 但還是不這麼容易，如果文件漏寫後人維護就會很痛苦；&lt;br>
用 Packer 就解決了 &lt;code>Image 建立過程不透明&lt;/code>、&lt;code>每次都要開關機器&lt;/code>的困擾&lt;/p>
&lt;h2 id="安裝">安裝&lt;/h2>
&lt;p>&lt;a class="link" href="https://www.packer.io/downloads.html" target="_blank" rel="noopener"
>Packer 下載連結&lt;/a>&lt;/p>
&lt;h2 id="指定基礎-image">指定基礎 Image&lt;/h2>
&lt;p>可以在 &lt;a class="link" href="https://aws.amazon.com/marketplace" target="_blank" rel="noopener"
>AWS Marketplace&lt;/a> 上找想要採用的 Image，或直接指定 ami-id，例如我在 us-east-1 使用 Ubuntu 18.04 LTS - Bionic 的 ami-id 是 &lt;code>ami-0d03e44a2333dea65&lt;/code>，要找到 ami-id 其實有點小麻煩，可以參考下列步驟&lt;/p>
&lt;p>&lt;img src="https://yuanchieh.page/post/img/20200415/amiid.png"
loading="lazy"
>&lt;br>
先找到 Image，點進去後按 &amp;ldquo;Continue to Subscribe&amp;rdquo; -&amp;gt; &amp;ldquo;Continue to Configuration&amp;rdquo; (沒截圖)，接著選定區域就能看到 ami-id 了&lt;/p>
&lt;h2 id="packer-設定檔">Packer 設定檔&lt;/h2>
&lt;p>Packer 的設定檔是 json 格式，內容相當簡單明瞭，主要四塊&lt;/p>
&lt;ul>
&lt;li>&lt;code>variables&lt;/code>&lt;br>
文件有說為了變數管理方便，後續設定檔的參數全部都要定義在這裡&lt;/li>
&lt;li>&lt;code>builders&lt;/code>&lt;br>
指定的平台與對應的建立方式，如 AWS 要指定 credential / region / vpc 等&lt;/li>
&lt;li>&lt;code>provisioners&lt;/code>&lt;br>
Image 要執行的設定，可以用 shell 執行 / file 上傳檔案，或是其他的 provisioning 工具如 Ansible 等&lt;/li>
&lt;li>&lt;code>post-processors&lt;/code>&lt;br>
產生 Image 的後處理，可以壓縮上傳到指定位置等，這邊先略過&lt;/li>
&lt;/ul>
&lt;p>以下檔案是建立 API server image，基於 ubuntu 安裝 Nodejs 並將 Server 檔案上傳至指定路徑執行，所以的設定檔在github 上 &lt;a class="link" href="https://github.com/sj82516/packer_get_started" target="_blank" rel="noopener"
>packer_get_started&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;variables&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;aws_access_key&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;{{env `AWS_ACCESS_KEY_ID`}}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;aws_secret_key&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;{{env `AWS_SECRET_ACCESS_KEY`}}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;region&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;us-east-1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;builders&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;type&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;amazon-ebs&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;access_key&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;{{user `aws_access_key`}}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;secret_key&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;{{user `aws_secret_key`}}&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;region&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;us-east-1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;source_ami&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;ami-0d03e44a2333dea65&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;instance_type&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;t2.micro&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;ssh_username&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;ubuntu&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;ami_name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;packer-example {{timestamp}}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;provisioners&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;type&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;shell&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;script&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;init.sh&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;type&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;shell&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;inline&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;ls&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;pwd&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;type&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;file&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;source&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;server&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;destination&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;~/server&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;type&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;shell&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;script&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;start.sh&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在 json 檔中，變數取用都是以 &lt;code>{{}}&lt;/code> 雙括號括住，只有在 &lt;code>variables&lt;/code> 中可以用 &lt;code>env&lt;/code> 指定使用環境變數，也可以留空在 command line 執行時指定，如 &lt;code>$ packer build -var 'aws_access_key=YOUR ACCESS KEY' ...&lt;/code> &lt;br>
來源還可以從 Consul / Vault 等地方，可以參考文件&lt;/p>
&lt;p>後續階段要讀取就要用&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="o">{{&lt;/span>user &lt;span class="sb">`&lt;/span>aws_access_key/&lt;span class="sb">`&lt;/span>&lt;span class="o">}}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>的形式讀取 variables 中的參數&lt;/p>
&lt;h4 id="builders">builders&lt;/h4>
&lt;p>可以看到 &lt;code>builders&lt;/code> 是以陣列形式，這邊可以指定多個建立的目標，例如增加 vmware / virtualbox 等等，Packer 會併發建立 Image&lt;/p>
&lt;h4 id="provisioner">provisioner&lt;/h4>
&lt;p>常用搭配 &lt;code>shell&lt;/code> / &lt;code>file&lt;/code> 執行 shell script 或是上傳本地端資料到 server上，可以指定在某些目標下才複寫，如&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;type&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;shell&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;script&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;script.sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;override&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;vmware-iso&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;execute_command&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;echo &amp;#39;password&amp;#39; | sudo -S bash {{.Path}}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Packer 大概就是這麼簡單! Do one thing and do it well. &lt;br>
執行的時候照樣 hashicorp 工具的操作方式，&lt;code>$packer validate&lt;/code> 先檢查語法正確性，接著 &lt;code>$packer build&lt;/code> 就完成囉&lt;/p>
&lt;p>最後看一下 Packer 每次 Build 所產生的 instance &lt;br>
&lt;img src="https://yuanchieh.page/post/img/20200415/packer-tm.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="使用經驗談">使用經驗談&lt;/h2>
&lt;p>以下分享一些實際遇到的問題與解決辦法&lt;/p>
&lt;h3 id="使用-aws-build-image-偶爾遇到-package-安裝失敗的問題">使用 AWS build Image 偶爾遇到 package 安裝失敗的問題&lt;/h3>
&lt;p>症狀大概是 Packer 在執行 &lt;code>$sudo apt-get install&lt;/code> 時偶發說 package not found，但偶爾可以，且進去機器安裝網路狀況都是沒問題的&lt;/p>
&lt;p>問題主要出自於開啟 AWS 機器時有可能網路還沒有好，所以才會是偶發性，解決辦法就是確認網路好才開始執行 shell script，詳細請參考 Packer Github Issue &lt;a class="link" href="https://github.com/hashicorp/packer/issues/2639" target="_blank" rel="noopener"
>Option for builder to wait on cloud-init to complete&lt;/a>&lt;/p>
&lt;p>在 provisions 第一步加入以下 script (答案摘錄自上方 issue 回覆)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">provisions:&lt;span class="o">[{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;type&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;shell&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;inline&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;/usr/bin/cloud-init status --wait&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">....
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="希望在-launch-機器時就啟動服務">希望在 launch 機器時就啟動服務&lt;/h3>
&lt;p>這比較偏原有的系統 service 設定，使用 ubuntu 的話可以設定 systemd service，並指定 target 就可以在 launch 機器時啟動，詳細參考
&lt;a class="link" href="https://www.digitalocean.com/community/tutorials/how-to-use-systemctl-to-manage-systemd-services-and-units" target="_blank" rel="noopener"
>How To Use Systemctl to Manage Systemd Services and Units&lt;/a> 與&lt;br>
&lt;a class="link" href="https://www.digitalocean.com/community/tutorials/understanding-systemd-units-and-unit-files" target="_blank" rel="noopener"
>Understanding Systemd Units and Unit Files&lt;/a> 兩篇來自 DigitalOcean 的好文，預計這篇會在產出一篇文章 (挖坑)&lt;/p>
&lt;h3 id="希望在-launch-機器後取得機器資訊與-ip">希望在 launch 機器後取得機器資訊與 IP&lt;/h3>
&lt;p>這應該是蠻實用的需求，像是綁定一些網路服務，會需要在 config 檔指定機器的 IP 等，須注意這邊要等到 launch 後才綁定，而不是在 Packer Build 的機器產生，所以會結合上一點，指定 script 在機器啟動後才執行&lt;/p>
&lt;ol>
&lt;li>取得 AWS 機器資訊&lt;/li>
&lt;li>取得 IPv6&lt;/li>
&lt;li>修改文件&lt;/li>
&lt;/ol></description></item><item><title>Vagrant 教學- 從本地端開發到 AWS 部署</title><link>https://yuanchieh.page/posts/2020/2020-04-12-vagrant-%E6%95%99%E5%AD%B8-%E5%BE%9E%E6%9C%AC%E5%9C%B0%E7%AB%AF%E9%96%8B%E7%99%BC%E5%88%B0-aws-%E9%83%A8%E7%BD%B2/</link><pubDate>Sun, 12 Apr 2020 11:21:40 +0000</pubDate><guid>https://yuanchieh.page/posts/2020/2020-04-12-vagrant-%E6%95%99%E5%AD%B8-%E5%BE%9E%E6%9C%AC%E5%9C%B0%E7%AB%AF%E9%96%8B%E7%99%BC%E5%88%B0-aws-%E9%83%A8%E7%BD%B2/</guid><description>&lt;p>大綱 &lt;a class="link" href="https://yuanchieh.page/posts/2020/2020-04-12-infrusture-as-code-%E6%8C%91%E6%88%B0%E8%B3%BD-hashicorp-%E5%B7%A5%E5%85%B7%E9%8F%88%E5%85%A8%E6%95%99%E5%AD%B8/" target="_blank" rel="noopener"
>Infrusture as Code 挑戰賽 - Hashicorp 工具鏈全教學&lt;/a>&lt;/p>
&lt;p>Vagrant 主要是建立與管理 VM 的工具，主要希望在工作流程中提供一致的環境，例如說有新人加入開發，需要在本地端設定 Runtime 環境 / 資料庫等，這時候如果用 Vagrant 使用 &lt;code>$vagrant up&lt;/code> 一鍵啟動所有需要的環境，就非常的方便，也可以避免「明明在我的電腦就沒問題」的尷尬&lt;/p>
&lt;p>Vagrant 主要是 VM-based 的工具，預設使用 Virtualbox，也可以用 VMWare / AWS 等虛擬化平台&lt;/p>
&lt;p>本次教學目標為部署一個 nodejs api server + mongodb&lt;/p>
&lt;p>github repo 在此 &lt;a class="link" href="https://github.com/sj82516/vagrant-getting-started" target="_blank" rel="noopener"
>vagrant-getting-started&lt;/a>&lt;/p>
&lt;h2 id="install">Install&lt;/h2>
&lt;p>&lt;a class="link" href="https://www.vagrantup.com/downloads.html" target="_blank" rel="noopener"
>下載 Vagrant&lt;/a>&lt;br>
&lt;a class="link" href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener"
>下載 Virtualbox&lt;/a>&lt;/p>
&lt;h2 id="terminology">Terminology&lt;/h2>
&lt;p>在 Vagrant 有幾個名詞先介紹&lt;/p>
&lt;ol>
&lt;li>&lt;code>provider&lt;/code>:&lt;br>
提供 Vagrant 虛擬化的環境，預設是 virtualbox，也可以是其他的第三方 provider&lt;/li>
&lt;li>&lt;code>box&lt;/code>:&lt;br>
對比是 Docker 的 Image，也就是 Vagrant 虛擬化啟動的 Image，透過這個基礎再去客製化，以下用 ubuntu 示範&lt;/li>
&lt;li>&lt;code>provision&lt;/code>:&lt;br>
客製化環境的每一個步驟，可以用 &lt;code>shell&lt;/code>執行 shell script、&lt;code>file&lt;/code> 上傳檔案，或是搭配 &lt;code>chef/ansible&lt;/code> 等 provisioning 工具&lt;/li>
&lt;/ol>
&lt;h2 id="get-started">Get Started!&lt;/h2>
&lt;p>首先建立一個檔案夾 &lt;code>vagrant-demo&lt;/code>，先拉下等等要用的 box，&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="line">&lt;span class="cl">[Host]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ vagrant box add ubuntu/trusty64
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以在這邊找到你想要的 box，&lt;a class="link" href="https://app.vagrantup.com/boxes/search" target="_blank" rel="noopener"
>Discover Vagrant Boxes&lt;/a>&lt;/p>
&lt;p>接著建立 &lt;code>Vargrantfile&lt;/code> 文件，裡頭寫入&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="line">&lt;span class="cl">&lt;span class="no">Vagrant&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">configure&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;2&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">do&lt;/span> &lt;span class="o">|&lt;/span>&lt;span class="n">config&lt;/span>&lt;span class="o">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">config&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">vm&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">box&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;ubuntu/trusty64&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>首先看一下語法，Vagrant 設定檔是用 Ruby 語法，當然不會 Ruby 也可以使用，&lt;code>Vagrant.configure(&amp;quot;2&amp;quot;)&lt;/code> 定義 Vagrant 的語法版本，接著 &lt;code>do |config| ... end&lt;/code> 定義 vm 的設定，config 是我們在這個 block 中的 vm 名稱；&lt;br>
&lt;code>config.vm.box&lt;/code> 則是指定採用的 box，config.vm 底下有很多參數可以指定，請&lt;a class="link" href="https://www.vagrantup.com/docs/vagrantfile/machine_settings.html" target="_blank" rel="noopener"
>參考文件&lt;/a>&lt;/p>
&lt;p>接著執行&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Host&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ vagrant up
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果安裝正確，vagrant 會直接啟動新的 vm，如果直接開 virtuabox 會看到一個新的 vm instance &lt;br>
&lt;code>$vagrant up&lt;/code> 表示依序路徑讀取 &lt;code>Vagrantfile&lt;/code>(當前路徑 &amp;ndash;沒有找到再往&amp;ndash;&amp;gt; ../當前路徑 -&amp;gt; &amp;hellip;.)，並啟動新的 vm instance，啟動後會發現路徑下多了 &lt;code>./.vagrant&lt;/code> 的資料夾，這主要是記錄 vagrant 執行狀態&lt;/p>
&lt;p>接著讓我們 ssh 進入 vm 看一下&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Host&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ vagrant ssh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>ssh 用的 key 等等 vagrant 都處理好了，ssh 進入後，預設操作的 user 是 &lt;code>vagrant&lt;/code>，先看一下 &lt;code>/vagrant&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>VM&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ ls /vagrant
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你會意外發現 /vagrant 裡頭竟然有 Vagrantfile，主要是 vagrant 預設會把本地端 Vagrantfile 同在的資料夾一並同步到 vm 底下的 /vagrant 當中&lt;br>
依照共享的不同，可能是 &lt;code>rsync&lt;/code> 一次性複製，也可以透過 SMB 雙向同步共享資料夾&lt;/p>
&lt;h3 id="provisioning">provisioning&lt;/h3>
&lt;p>接著我們安裝上 nodejs，讓我們透過 shell script 安裝 nvm，並建立 server 資料夾放到 vm 中，接著透過 pm2 啟動&lt;br>
將 Vagrantfile 改成&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="line">&lt;span class="cl">&lt;span class="no">Vagrant&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">configure&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;2&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">do&lt;/span> &lt;span class="o">|&lt;/span>&lt;span class="n">config&lt;/span>&lt;span class="o">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">config&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">vm&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">box&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;ubuntu/trusty64&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">config&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">vm&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">provision&lt;/span> &lt;span class="ss">:shell&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">path&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;init.sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">privileged&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kp">false&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">config&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">vm&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">provision&lt;/span> &lt;span class="s2">&amp;#34;file&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">source&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;server&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">destination&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;/home/vagrant/&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">config&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">vm&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">provision&lt;/span> &lt;span class="ss">:shell&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">path&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;start.sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">privileged&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kp">false&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">config&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">vm&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">synced_folder&lt;/span> &lt;span class="s2">&amp;#34;.&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;/vagrant&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">id&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;sync&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="ss">type&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;rsync&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="ss">rsync__exclude&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="o">[&lt;/span>&lt;span class="s2">&amp;#34;.git/&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;server/&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;start.sh&amp;#34;&lt;/span>&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>每一個 &lt;code>config.vm.provision&lt;/code> 代表一個步驟，我們指定了&lt;/p>
&lt;ol>
&lt;li>執行 init.sh：主要是安裝 nvm 與 pm2&lt;/li>
&lt;li>&lt;code>file&lt;/code> 是用來複製檔案，將 server 路徑複製到 /home/vagrant/ 底下&lt;/li>
&lt;li>start.sh 主要是啟動 nodejs server&lt;/li>
&lt;/ol>
&lt;p>&lt;code>config.vm.synced_folder&lt;/code> 則是顯示指定我們要同步到 /vagrant 底下的資料，也可以指定到其他資料夾下，不過要小心處理檔案路徑&lt;/p>
&lt;p>接著執行&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>Host&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ vagrant provision
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意如果這時候跑 $ vagrant up 是沒有用的，因為 vm 已經啟動了，如果是 Vagrantfile 增加 provision，記得用 &lt;code>$ vagrant provision&lt;/code>或 &lt;code>$ vagrant reload --provision&lt;/code>，如果是 Vagrantfile 其他設定檔有更動，請用 &lt;code>$ vagrant reload&lt;/code>&lt;/p>
&lt;p>此時 ssh 登入後可以看到 nodejs server 已經在執行了&lt;/p>
&lt;p>這時候好好說一下 shell 需要注意的地方，&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">....
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">source&lt;/span> ~/.nvm/nvm.sh
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">nvm install &lt;span class="m">12&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">npm install -g pm2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看到我在 init.sh / start.sh 要呼叫 nvm/pm2 之前都要 &lt;code>$source ~/.nvm/nvm.sh&lt;/code> 而非 &lt;code>$source ~/.bash.sh&lt;/code>，主要是因為預設 vagrant 的 .bashrc 有這一段&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># If not running interactively, don&amp;#39;t do anything&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">case&lt;/span> &lt;span class="nv">$-&lt;/span> in
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> *i*&lt;span class="o">)&lt;/span> &lt;span class="p">;;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> *&lt;span class="o">)&lt;/span> &lt;span class="k">return&lt;/span>&lt;span class="p">;;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">esac&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而我們又將 nvm 的啟動 script 放在這一段之後才會導致 shell 找不到 nvm command，所以要改成&lt;code>$source ~/.nvm/nvm.sh&lt;/code>，這部分是參考 stackoverflow &lt;a class="link" href="https://stackoverflow.com/questions/38555554/why-is-nvm-command-installed-as-root-and-also-not-found-during-vagrant-bootstrap" target="_blank" rel="noopener"
>Why is nvm command installed as root and also not found during vagrant bootstrap.sh?&lt;/a>&lt;/p>
&lt;p>其他的 provisioning 工具搭配請&lt;a class="link" href="https://www.vagrantup.com/docs/provisioning/" target="_blank" rel="noopener"
>參考文件&lt;/a>&lt;/p>
&lt;h3 id="destroy">destroy&lt;/h3>
&lt;p>如果開發過程中有誤，建議 Vagrantfile 改完砍到 vm 重來，使用
&lt;code>$ vagrant destroy&lt;/code>，主要是每次執行 $ vagrant provision 會不斷在原本的 vm instance 操作，這樣會導致每次疊加結果而違反 immutable&lt;/p>
&lt;h3 id="network">network&lt;/h3>
&lt;p>在 Vagrant 中，網路大致有三種設定方式&lt;/p>
&lt;ol>
&lt;li>&lt;code>Port Forward&lt;/code>&lt;br>
讓 Host 環境可以用指定 port 對應 VM 中的 port&lt;/li>
&lt;li>&lt;code>Private Network&lt;/code>&lt;br>
指定 private ip 讓內網的機器都能透過 ip 溝通&lt;/li>
&lt;li>&lt;code>Public Network&lt;/code>&lt;br>
Vagrant 預設整合 Ngrok，可以用公開連結連線&lt;/li>
&lt;/ol>
&lt;p>此時 nodejs server 只能在 vm 內部使用，我們用 Port Forward 方式讓 host 也可以呼叫 &lt;br>
修改 Vagrantfile&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="line">&lt;span class="cl">&lt;span class="no">Vagrant&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">configure&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;2&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">do&lt;/span> &lt;span class="o">|&lt;/span>&lt;span class="n">config&lt;/span>&lt;span class="o">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">config&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">vm&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">network&lt;/span> &lt;span class="s2">&amp;#34;forwarded_port&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">guest&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">80&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">host&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">8080&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接著用 &lt;code>$ vagrant reload&lt;/code>
這時候在 Host 就可以發請求到 VM 上囉 &lt;code>$ curl localhost:8080&lt;/code>&lt;/p>
&lt;h2 id="小結">小結&lt;/h2>
&lt;p>在 Provisioning 部分，個人覺得用 shell script 有點不太方便，例如說切換 OS 時 script 就需要修改，而且很指令式而非宣告式，如果能用其他的 provisioning tool 去管理，又或是使用 image / container 去隔離對底層 OS 的相依，這勢必會方便很多&lt;/p>
&lt;p>Vagrant 有提供 AWS provider，但因為是社群開發套件就暫且不試，專注在搭建本地端的開發環境&lt;/p>
&lt;p>目前是只有一台 api server，接著要配置 DB 並放在同一個 Vagrantfile 中整理&lt;/p>
&lt;h2 id="multi-machile">Multi machile&lt;/h2>
&lt;p>如果要在 Vagrantfile 中定義多個 vm instance，可以透過 &lt;code>config.vm.define&lt;/code> 區隔，預設會繼承全域的所有 provision，但是個別定義中可以複寫或是客製化，如以下&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="line">&lt;span class="cl">&lt;span class="no">Vagrant&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">configure&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;2&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">do&lt;/span> &lt;span class="o">|&lt;/span>&lt;span class="n">config&lt;/span>&lt;span class="o">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">config&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">vm&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">box&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;ubuntu/trusty64&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">config&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">vm&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">define&lt;/span> &lt;span class="s2">&amp;#34;api&amp;#34;&lt;/span> &lt;span class="k">do&lt;/span> &lt;span class="o">|&lt;/span>&lt;span class="n">api&lt;/span>&lt;span class="o">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">api&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">vm&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">provision&lt;/span> &lt;span class="ss">:shell&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">path&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;init.sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">privileged&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kp">false&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">api&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">vm&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">provision&lt;/span> &lt;span class="s2">&amp;#34;file&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">source&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;server&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">destination&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;/home/vagrant/&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">api&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">vm&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">provision&lt;/span> &lt;span class="ss">:shell&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">path&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;start.sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">privileged&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kp">false&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">api&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">vm&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">synced_folder&lt;/span> &lt;span class="s2">&amp;#34;.&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;/vagrant&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">id&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;sync&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="ss">type&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;rsync&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="ss">rsync__exclude&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="o">[&lt;/span>&lt;span class="s2">&amp;#34;.git/&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;server/&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;start.sh&amp;#34;&lt;/span>&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">api&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">vm&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">network&lt;/span> &lt;span class="s2">&amp;#34;forwarded_port&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">guest&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">3000&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">host&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">8080&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">end&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">config&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">vm&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">define&lt;/span> &lt;span class="s2">&amp;#34;db&amp;#34;&lt;/span> &lt;span class="k">do&lt;/span> &lt;span class="o">|&lt;/span>&lt;span class="n">db&lt;/span>&lt;span class="o">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">db&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">vm&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">provision&lt;/span> &lt;span class="ss">:shell&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">path&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;./mongodb/install.sh&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ss">privileged&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kp">false&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">end&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果想要指定其中一台下指令，針對名稱就好如 &lt;code>$vagrant ssh db&lt;/code>&lt;/p>
&lt;h2 id="結語">結語&lt;/h2>
&lt;p>個人覺得開發&lt;code>不推薦&lt;/code>用 Vagrant (那怎麼花了一個假日&amp;hellip;)，主要是社群看起來沒有很活躍，例如最多人下載的 box ubuntu/trusty64 還是在 14.04 的版本，想要直接找 Mongodb 的 box 也沒有(大多的 db 都沒有)，且整個配置上沒有很方便，例如 shell script 切換 os 就要重寫，還不如用 docker + docker compose 來得快速&lt;br>
但如果你是一定要用 vm 那或許 Vagrant 還是個不錯的選擇&lt;/p>
&lt;p>如果你有其他建議，又或是有覺得 Vagrant 有厲害獨特的應用場景再麻煩指教～&lt;/p></description></item><item><title>Infrusture as Code 挑戰賽 - Hashicorp 工具鏈全教學</title><link>https://yuanchieh.page/posts/2020/2020-04-12-infrusture-as-code-%E6%8C%91%E6%88%B0%E8%B3%BD-hashicorp-%E5%B7%A5%E5%85%B7%E9%8F%88%E5%85%A8%E6%95%99%E5%AD%B8/</link><pubDate>Sun, 12 Apr 2020 02:21:40 +0000</pubDate><guid>https://yuanchieh.page/posts/2020/2020-04-12-infrusture-as-code-%E6%8C%91%E6%88%B0%E8%B3%BD-hashicorp-%E5%B7%A5%E5%85%B7%E9%8F%88%E5%85%A8%E6%95%99%E5%AD%B8/</guid><description>&lt;p>最近開始接觸 DevOps 與 Infrasture as Code 的概念，深深被用程式碼管理部署流程與架構設計感到著迷，對工程師來說最棒的文件莫過於結構清晰、沒有重複冗余的乾淨程式碼，尤其是把過往透過人工操作的不穩定性一切攤開在陽光下用 Code Review 方式檢視每一個環節，讓程式碼從出生到部署都可以完整地被檢視；&lt;br>
再者在 Cloud-Native 時代，能夠跨區域部署、甚至混合雲部署能夠讓公司的性能與成本上獲得更大的彈性&lt;/p>
&lt;p>只是在學習過程中，被一堆技術工具轟炸，每個工具之間又有些重複又不怎麼相同的功能，又或是抽象畫層級不同 (Container vs VM)，像是 Chef / Ansible / Terraform / Kubernetes / Docker 等等，每次東學一些西學一些總是一個頭兩個大，最近看了來自 Hashicorp 的介紹影片以及一篇文章整理，覺得在觀念上更加的融會貫通，至少更清楚知道 &lt;code>部署的流程&lt;/code> 與對應的工具應用&lt;/p>
&lt;div class="video-wrapper">
&lt;iframe loading="lazy"
src="https://www.youtube.com/embed/wyRtz_tdJes"
allowfullscreen
title="YouTube Video"
>
&lt;/iframe>
&lt;/div>
&lt;p>&lt;a class="link" href="https://blog.gruntwork.io/why-we-use-terraform-and-not-chef-puppet-ansible-saltstack-or-cloudformation-7989dad2865c" target="_blank" rel="noopener"
>Why we use Terraform and not Chef, Puppet, Ansible, SaltStack, or CloudFormation&lt;/a>&lt;/p>
&lt;p>簡單總結一下上面兩個參考資料的想法&lt;/p>
&lt;h2 id="application-delivery-with-hashicorp">Application Delivery with HashiCorp&lt;/h2>
&lt;p>當在開發應用程式時，要正確地交付到用戶手中有一段路要走，主要分成幾個階段&lt;/p>
&lt;h3 id="1-write-本地開發">1. Write 本地開發&lt;/h3>
&lt;p>在本地端開發時，開發者會需要有跟正式環境類似的配置，例如資料庫等，這時候可以用 &lt;code>Vagrant&lt;/code> 建制開發環境&lt;/p>
&lt;h3 id="2-test-測試">2. Test 測試&lt;/h3>
&lt;p>進行測試時也需要一個乾淨、獨立、與正式環境接近的配置，同樣能用 &lt;code>Vagrant&lt;/code>&lt;/p>
&lt;h3 id="3-package-打包應用程式">3. Package 打包應用程式&lt;/h3>
&lt;p>當程式碼測試完，要準備部署時，還需要把設定檔、環境變數等一併打包變成一個可部署的最小單元，此時能用 &lt;code>Packer&lt;/code> 依據不同環境(AWS/GCP&amp;hellip;)打包出 Image&lt;/p>
&lt;h3 id="4-provision-day1day2-機器的環境設定">4. Provision (Day1/Day2+) 機器的環境設定&lt;/h3>
&lt;p>應用程式需要完整的架構設計，例如說 CDN / DNS / Networking / Firewall / Storage System 等等，這時候可以用 &lt;code>Terraform&lt;/code> 配置 dev/stage/prod 環境&lt;/p>
&lt;h3 id="5-deploy-部署方式-orchestration">5. Deploy 部署方式 (Orchestration)&lt;/h3>
&lt;p>部署方式常見有 Canary / Blue-Green 等，又或是遇到流量起伏時的 Auto-Scaling，可以用 &lt;code>Nomand&lt;/code>，將 Dev 跟 Ops 獨立拆分，Dev 只需要專注在需要的運算資源、部署流程的掌握，Ops 則負責底層的機器配置、數量管控、機器的安全性補丁等&lt;/p>
&lt;h3 id="6-monitor-監控">6. Monitor 監控&lt;/h3>
&lt;p>Hashicorp 目前沒有直接相關的產品，但有提供 &lt;code>Consul&lt;/code>，如果是採用 Microservice / SOA 架構，內部服務間如何發現彼此需要內部的 DNS處理 / 機器要怎麼管理 config 都是個問題，Consul 透過 Key/Store 儲存解決這類的問題&lt;/p>
&lt;h3 id="7-security">7. Security!&lt;/h3>
&lt;p>另一個不再流程中但開發者需時時牢記在心 &lt;code>Security&lt;/code>，一般來說 key 會在打包階段被一並放進，但是這樣相對不太安全，&lt;code>Vault&lt;/code> 提供key 自動 rotate / 中心化管理 credential / 中心化處理加解密過程，降低機器被攻陷後的影響與更快速彈性的替換 key，增加安全性保證&lt;/p>
&lt;p>以上工具都能夠整合 VM / Container based 的環境，也有許多不同的替代方案；&lt;br>
例如 Docker 可以單獨吃掉 Write/Test/Package 的功能，K8S 則負責 Deploy 與 Monitoring，如果是託管於 Cloud 則由 Cloud 負責 部分Provision的功能(如 Load Balancer，但不會自動設定 Public DNS 或 S3 這類架構)&lt;/p>
&lt;p>其中 &lt;code>Nomand&lt;/code> 跟 K8S 比較是互補的工具，Hashicorp 提到 K8s 上手學習曲線太高，很多時候我們不一定要這麼複雜但強大的工具，如果原本是 VM based 架構那用 Nomand 管理部署會輕鬆、直觀很多&lt;/p>
&lt;h2 id="why-we-use-terraform-and-not-chef-puppet-ansible-saltstack-or-cloudformation">Why we use Terraform and not Chef, Puppet, Ansible, SaltStack, or CloudFormation&lt;/h2>
&lt;p>這篇的作者非常厲害，之前拜讀了全部的 Terraform 教學個人覺得比官網更實在，這一篇文章含金量一樣超高，從更高層級的角度看這類型的工具，&lt;strong>Chef, Puppet, Ansible, SaltStack&lt;/strong> 主要是做 &lt;code>Configuration management&lt;/code>，也就是一台乾淨的機器啟動後要做什麼配置，例如 API Server 需要安裝 program runtime 並部署程式碼 / DB server 要安裝 DB 並搭配安全性配置等等&lt;/p>
&lt;p>而 Terraform / CloudFormation 是 &lt;code>Provision&lt;/code>，是配置整個架構，所以兩者的討論面向不同，雖然像 Ansible 也能做一些 Provision 工作，但相較就不適合&lt;/p>
&lt;p>接著是 &lt;code>Mutable / Immutable&lt;/code> 的問題，Chef/Ansible 等工具在產生配置變化時會在同一台機器發生，也就是 Mutable，當累積的變化變多時可能會有配置衝突的問題；&lt;br>
如果是用 Terrform 搭配 Packer/Docker 等，每次都會產生新的機器，所以是 Immutable，行為相對比較單純且可預測&lt;/p>
&lt;p>接著作者還從語法上、管理上、社群大小做了比對。&lt;/p>
&lt;p>技術層面上可以做不同混搭，例如 Terraform + Ansible，配置好架構後用 Ansible 管理每一台機器的設定；
又或是 Terraform + Packer + Docker + Kubernetes，一樣架構配置好且機器的 Image 預設都裝有 Docker 與 K8s agent，後續用 K8s 管理部署的流程&lt;/p>
&lt;h2 id="實作">實作&lt;/h2>
&lt;p>看完對於整個部署流程與工具更加的理解了，此時當然要挑戰自己動手搭建整個環境，以 API Server + DB 的架構去挑戰 Hashicorp 全套工具鍊，希望用一個月左右時間完成，以下是完整的教學記錄，希望能夠幫助到大家&lt;/p>
&lt;p>&lt;a class="link" href="https://yuanchieh.page/post/2020-04-12_vagrant-%E6%95%99%E5%AD%B8-%E4%B8%80%E9%8D%B5%E5%95%9F%E5%8B%95%E9%85%8D%E7%BD%AE%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83/" target="_blank" rel="noopener"
>Vagrant 教學-一鍵啟動配置開發環境&lt;/a>&lt;br>
&lt;a class="link" href="https://yuanchieh.page/post/2020-04-15_packer-%E6%95%99%E5%AD%B8-%E6%89%93%E9%80%A0-image-copy/" target="_blank" rel="noopener"
>Packer 教學- 打造 Image&lt;/a> &lt;br>
&lt;a class="link" href="https://yuanchieh.page/post/2020-04-20_vault-%E6%95%99%E5%AD%B8-%E9%9B%86%E4%B8%AD%E5%8C%96%E7%AE%A1%E7%90%86%E6%A9%9F%E6%95%8F%E8%B3%87%E6%96%99-%E4%B8%8A/" target="_blank" rel="noopener"
>Vault 教學-集中化管理機敏資料 (上)&lt;/a>
&amp;hellip;待續&lt;/p></description></item><item><title>初試 Terraform - 基本介紹與用程式碼部署 Lambda (下)</title><link>https://yuanchieh.page/posts/2019/2019-11-04-%E5%88%9D%E8%A9%A6-terraform-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%B4%B9%E8%88%87%E7%94%A8%E7%A8%8B%E5%BC%8F%E7%A2%BC%E9%83%A8%E7%BD%B2-lambda-%E4%B8%8B/</link><pubDate>Mon, 04 Nov 2019 00:21:40 +0000</pubDate><guid>https://yuanchieh.page/posts/2019/2019-11-04-%E5%88%9D%E8%A9%A6-terraform-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%B4%B9%E8%88%87%E7%94%A8%E7%A8%8B%E5%BC%8F%E7%A2%BC%E9%83%A8%E7%BD%B2-lambda-%E4%B8%8B/</guid><description>&lt;h1 id="介紹">介紹&lt;/h1>
&lt;p>&lt;a class="link" href="https://yuanchieh.page/post/2019-10-31_try-terraform/" target="_blank" rel="noopener"
>上一篇&lt;/a>完成了用 Terraform 實作單一區域定時執行 Lambda 的部署，這一篇將轉成 module，並使用 for loop / if condition，一次部署到多個區域，同時探索 Terraform 本次教學沒有用到卻也值得留意的功能&lt;/p>
&lt;h1 id="module---模組化">Module - 模組化&lt;/h1>
&lt;p>先前提到，只要在專案根目錄下，任何的 &lt;code>*.tf&lt;/code> 檔案都是 root module，在 &lt;code>$terraform apply&lt;/code> 時都會被執行；&lt;br>
如果要獨立出個別的模組，可以放在不同專案下，透過放在 github、s3 等 remote 方式載入，又或是單純獨立出一個資料夾放置，用路徑的方式載入，先重整原本的專案資料夾架構&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="line">&lt;span class="cl">---
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> |--- main.tf // 進入點
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> |--- input.tf // 定義參數
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> |--- output.tf // 定義輸出
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> |--- modules // 存放所有的路徑
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> |--- lambda-api-test
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> |--- main.tf // module 的進入點
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> |--- input.tf // module input
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> |--- lambda-function.zip
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ... 上一篇所有的資料
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> |--- global
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> |--- global.tf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>重新思考之後要部署的架構，&lt;code>global&lt;/code> 用來存放全域的資源，例如說 IAM Role / DNS 等資源，這部分會需要先被創立，方便後續的資源綁定；&lt;/p>
&lt;p>接著把各區域相同的架構包成 module 放置在 modules 底下，程式碼移除 IAM 資源，其餘大多雷同，只是要注意如果有用到 file 相關的參數，要改變路徑位置為 &lt;code>${path.module}&lt;/code>，否則會找不到資源；&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-HCL" data-lang="HCL">&lt;span class="line">&lt;span class="cl">&lt;span class="k">resource&lt;/span> &lt;span class="s2">&amp;#34;aws_lambda_layer_version&amp;#34; &amp;#34;lambda-layer_fetch&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> filename&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;${path.module}/lambda_layer_payload.zip&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> layer_name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;lambda_layer_name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> source_code_hash&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;${filebase64sha256(&amp;#34;${path.module}/lambda_layer_payload.zip&amp;#34;)}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> compatible_runtimes&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;nodejs10.x&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果要引用 module，也就是 &lt;code>./main.tf&lt;/code> 的內容為&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-HCL" data-lang="HCL">&lt;span class="line">&lt;span class="cl">&lt;span class="k">locals&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> region&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;us-east-1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">provider&lt;/span> &lt;span class="s2">&amp;#34;aws&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> profile&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;default&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> region&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;${locals.region}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">module&lt;/span> &lt;span class="s2">&amp;#34;lambda-api-test_us-west-2&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> source&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;./modules/lambda-api-test&amp;#34;&lt;/span>&lt;span class="c1">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"> # depends_on = [&amp;#34;aws_iam_role.iam_for_lambda&amp;#34;]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> region&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;${local.region}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> lambda_variables-SLACK_URL&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;slack url&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> iam_role_name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">var&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">lambda_role_name&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>宣告 module 並透過相對路徑指定 source，其餘的參數對應 module 的 input；&lt;br>
要注意目前 v0.12 &lt;code>module 不支援 depends_on&lt;/code>，這也是為什麼 IAM Role 創立要獨立到 global.tf 先執行，不然目前無法先建立 IAM Role 再建立 module&lt;/p>
&lt;h3 id="locals">locals&lt;/h3>
&lt;p>locals 用來宣告區域變數，就像是寫程式中僅用於限定範圍內的變數，後續透過 &lt;code>local.{var}&lt;/code> 取用&lt;/p>
&lt;h1 id="data-source">data source&lt;/h1>
&lt;p>如果有需要跨檔案路徑存取資源，又或是讀取某些資料例如 AWS 所有的可部署區域列表，又或是執行某些指令如呼叫 lambda，可以宣告 data source；&lt;br>
data source 跟 resource 最大差別是 data source 是&lt;code>唯讀&lt;/code>，並大多數執行於 apply 階段之前，後續的資源建立都可以使用；&lt;br>
而 resource 則是會被 &lt;code>$terraform&lt;/code> 指令影響而增加、刪除、修改資源。&lt;/p>
&lt;p>看到 data source 讓我十分的興奮! 因為這代表我們有更好的方式與&lt;code>既有的架構共存&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>如果你擔心導入 Terraform 會不小心破壞現有的架構，可以透過 data source 去擷取重要的資料同時保證 Terraform 不會修改或是刪除，例如說 DNS設定、IAM Role 等等&lt;/p>
&lt;/blockquote>
&lt;p>data source 個別取用方式可以查文件，最基本就是用 name 當作搜尋依據，例如說我在 &lt;code>./module/lambda-api-test/main.tf&lt;/code> 希望存取 &lt;code>./global/global.tf&lt;/code> 或是不存在於 terraform 專案下的 IAM Role，可以用&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-HCL" data-lang="HCL">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># data &amp;#34;資源類型&amp;#34; &amp;#34;資源名稱&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># { 搜尋條件與參數 }
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">data&lt;/span> &lt;span class="s2">&amp;#34;aws_iam_role&amp;#34; &amp;#34;iam_for_lambda&amp;#34;&lt;/span>{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;iam_role_name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}&lt;span class="c1">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 存取示範
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">resource&lt;/span> &lt;span class="s2">&amp;#34;aws_lambda_function&amp;#34; &amp;#34;lambda_main&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> role&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;${data.aws_iam_role.iam_for_lambda.arn}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">....&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>data source 也是用來跨 module 間傳遞資源的方法，但要自己釐清 module 的先後順序&lt;/p>
&lt;h1 id="條件式---for--if">條件式 - for / if&lt;/h1>
&lt;p>HCL 是個宣告式語言，讓我們可以用 high level 方式宣告我們的意圖，至於如何實作就不用我們操心；&lt;br>
但跟程序式語言比起來，條件判斷與迴圈等邏輯判斷舊沒有如此的方便，不過 HCL 還是支援基本的條件判斷語法，雖然沒這麼直觀，但還是有辦法滿足大多數的應用場景&lt;/p>
&lt;h1 id="count">count&lt;/h1>
&lt;p>count 是最早支援的語法，主要是重複創建資源，透過 &lt;code>count.index&lt;/code> 取得當下 interation 的 index&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-HCL" data-lang="HCL">&lt;span class="line">&lt;span class="cl">&lt;span class="k">resource&lt;/span> &lt;span class="s2">&amp;#34;aws_iam_user&amp;#34; &amp;#34;example&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="m">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;neo.${count.index}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>也可以搭配 list，動態調整變數&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-HCL" data-lang="HCL">&lt;span class="line">&lt;span class="cl">&lt;span class="k">variable&lt;/span> &lt;span class="s2">&amp;#34;user_names&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> description&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;Create IAM users with these names&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> type&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">list&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">string&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> default&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;neo&amp;#34;, &amp;#34;trinity&amp;#34;, &amp;#34;morpheus&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">resource&lt;/span> &lt;span class="s2">&amp;#34;aws_iam_user&amp;#34; &amp;#34;example&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">length&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">var&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">user_names&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">var&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">user_names&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="k">count&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">index&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果想要 access 資源的輸出，可以透過 &lt;code>[index/*]&lt;/code> 方式取得&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-HCL" data-lang="HCL">&lt;span class="line">&lt;span class="cl">&lt;span class="k">output&lt;/span> &lt;span class="s2">&amp;#34;all_arns&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">aws_iam_user&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">example&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">*&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="k">arn&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> description&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;The ARNs for all users&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>count 搭配三元運算式，就變成了現成的 if/else&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-HCL" data-lang="HCL">&lt;span class="line">&lt;span class="cl">&lt;span class="k">resource&lt;/span> &lt;span class="s2">&amp;#34;aws_iam_user_policy_attachment&amp;#34; &amp;#34;neo_cloudwatch_full&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">var&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">give_neo_cloudwatch_full_access&lt;/span> &lt;span class="err">?&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="err">:&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">....&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="count-限制">count 限制&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>不能用於 inline block&lt;/strong>&lt;br>
有些 resource 有 inline block，例如 auto scaling group 可以指定 tag，此時的 tag 不能使用 count&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-HCL" data-lang="HCL">&lt;span class="line">&lt;span class="cl">&lt;span class="k">resource&lt;/span> &lt;span class="s2">&amp;#34;aws_autoscaling_group&amp;#34; &amp;#34;example&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">....&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">tag&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="m">3&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">無法使用&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol start="2">
&lt;li>&lt;strong>採用 list 時的元素增減&lt;/strong>&lt;br>
如果創建資源時是用 list 搭配 count，必須注意 Terraform 在後續更新資源時是認定 list index 而非元素本身&lt;/li>
&lt;/ol>
&lt;p>例如原本是 [&amp;rsquo;ele1&amp;rsquo;, &amp;rsquo;ele2&amp;rsquo;, &amp;rsquo;ele3&amp;rsquo;]，此時希望刪除 ele2，變成 [&amp;rsquo;ele1&amp;rsquo;, &amp;rsquo;ele3&amp;rsquo;]&lt;br>
但是 Terraform 會解讀成 &lt;code>刪除 ele3，並更新 ele2 成 ele3&lt;/code>，這一點必須特別注意，不然就要使用其他的迴圈方式&lt;/p>
&lt;h1 id="for_each">for_each&lt;/h1>
&lt;p>for_each 是在 0.12 加入，可以輪詢指定的 collection，並支援 inline block!&lt;br>
如果 collection 為空值則效果等同於 count = 0&lt;/p>
&lt;blockquote>
&lt;p>如果多個 resource 本身近乎一致可以用 count，但大多數情況請用 for_each&lt;/p>
&lt;/blockquote>
&lt;p>配合 &lt;code>dynamic&lt;/code> 就可以用於 inline block，以下是建立 security group 時指定 ingress 多組 port&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-HCL" data-lang="HCL">&lt;span class="line">&lt;span class="cl">&lt;span class="k">resource&lt;/span> &lt;span class="s2">&amp;#34;aws_security_group&amp;#34; &amp;#34;example&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;example&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">dynamic&lt;/span> &lt;span class="s2">&amp;#34;ingress&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> for_each&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">var&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">service_ports&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">content&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> from_port&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">ingress&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">value&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> to_port&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">ingress&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">value&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> protocol&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;tcp&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>for_each 也可以搭配 map 使用&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-HCL" data-lang="HCL">&lt;span class="line">&lt;span class="cl">&lt;span class="k">resource&lt;/span> &lt;span class="s2">&amp;#34;azurerm_resource_group&amp;#34; &amp;#34;rg&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> for_each&lt;/span> &lt;span class="o">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> a_group&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;eastus&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> another_group&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;westus2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">each&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">key&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> location&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">each&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">value&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>透過 &lt;code>each 加上 key, value&lt;/code> 取得需要的值&lt;/p>
&lt;h1 id="warning">Warning!&lt;/h1>
&lt;p>目前 Terraform 還有幾個不支援的功能，例如說 &lt;code>provider 不支援變數&lt;/code>、&lt;code>module 不支援 depends_on&lt;/code>、&lt;code>module 不支援 for loop&lt;/code>&lt;/p>
&lt;p>這三個功能不支援讓 multiple region 部署時相當不方便，&lt;code>module 支援 for loop&lt;/code> 有在接下來的 Terraform roadmap 中，但還不確定何時會支援&lt;/p>
&lt;p>另在 Refactor 時務必注意，例如說 resource name 更新，Terraform 大多數會刪除舊資料並重建新資料，即使改個名稱而已，所以務必要仔細看 &lt;code>$ terraform plan&lt;/code> 的結果，避免造成不必要的 downtime&lt;/p>
&lt;p>或是有幾個方式可以避免 downtime&lt;/p>
&lt;ol>
&lt;li>&lt;strong>修改 lifecycle 為 create_before_destroy&lt;/strong> &lt;br>
每個 resource 可以指定 lifecycle，&lt;code>create_before_destroy&lt;/code> 會先創建新資源再刪除舊資源，避免 downtime&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-HCL" data-lang="HCL">&lt;span class="line">&lt;span class="cl">&lt;span class="k">resource&lt;/span> &lt;span class="s2">&amp;#34;azurerm_resource_group&amp;#34; &amp;#34;example&amp;#34;&lt;/span> {&lt;span class="c1">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"> # ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">lifecycle&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> create_before_destroy&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kt">true&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其他 lifecycle 還有 &lt;code>prevent_destroy&lt;/code> 不會Terraform 被刪除 以及 &lt;code>ignore_changes&lt;/code> 指定某些屬性更新不觸發 Terraform 更新資源
2. &lt;strong>使用 Terraform CLI 改變 state&lt;/strong> &lt;br>
像是要修改 resource 名稱，可以透過修改 state 而非資源本身即可 &lt;code>$ terraform state mv&lt;/code>，盡量透過指令去修改 state，而不是手動直接改 tfstate&lt;/p>
&lt;h1 id="結語">結語&lt;/h1>
&lt;p>&lt;a class="link" href="https://github.com/sj82516/terraform-investigation" target="_blank" rel="noopener"
>完整程式碼&lt;/a>，後來決定將上一篇的內容整理成 module，接著 iam role 部分獨立出來創立，接著用 &lt;code>data source&lt;/code> 方式引入；&lt;br>
多區域部署套用 &lt;code>module&lt;/code> 獨立宣告，可惜 for_each 尚未支援 module&lt;/p>
&lt;p>以下是 slack 的 log 畫面&lt;br>
&lt;img src="https://yuanchieh.page/post/img/20191104_slack_result.jpeg"
loading="lazy"
>&lt;/p>
&lt;p>對於導入 Terraform 評估蠻正面的，一來有 data source 或 import 與現有架構整合，又可以不擔心搞爛整個架構；&lt;br>
二來語法都慢慢完整，可以應付大多數的場景，確實省下很多的管理上的心力，期待之後可以用 Terraform 整合 Kubernetes，並整合 CI/CD，讓開發、整合、部署、維運可以更順暢&lt;/p>
&lt;p>接下來要繼續熟練 Terraform，希望挑戰整合 Docker 的跨區域跨 Provider 部署&lt;/p></description></item><item><title>初試 Terraform - 基本介紹與用程式碼部署 Lambda (上)</title><link>https://yuanchieh.page/posts/2019/2019-10-30-%E5%88%9D%E8%A9%A6-terraform-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%B4%B9%E8%88%87%E7%94%A8%E7%A8%8B%E5%BC%8F%E7%A2%BC%E9%83%A8%E7%BD%B2-lambda-%E4%B8%8A/</link><pubDate>Wed, 30 Oct 2019 00:21:40 +0000</pubDate><guid>https://yuanchieh.page/posts/2019/2019-10-30-%E5%88%9D%E8%A9%A6-terraform-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%B4%B9%E8%88%87%E7%94%A8%E7%A8%8B%E5%BC%8F%E7%A2%BC%E9%83%A8%E7%BD%B2-lambda-%E4%B8%8A/</guid><description>&lt;h1 id="介紹">介紹&lt;/h1>
&lt;p>Terraform 在 Github 上有一萬九千多顆星星(截自發文日)的開源專案，由 HashiCorp 這間專注於 DevOps 工具開發的公司所維護，主要透過 DSL 編寫定義檔，管理跨雲端架構，讓架構也可以程式碼化，近一步更好的&lt;code>協作&lt;/code>、&lt;code>版本控制&lt;/code>等好處，達到 Infrastructure as code 的目標。&lt;/p>
&lt;p>Terraform 可以達到以下幾件事：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>架構代碼化&lt;/strong>&lt;br>
Terraform 採用宣告式程式語言(declarative language)的 DSL，但同樣提供基礎的程式語言該有的功能，例如變數、輸入輸出、模組化等，其中模組化也支援加載外部模組，不用擔心違反 DRY，內建一些函示也都很好用；
當你有多個環境要部署時，可以用同樣的架構但是不同的機器規格與參數，管理上很方便&lt;/li>
&lt;li>&lt;strong>跨平台服務&lt;/strong>&lt;br>
Azure / GCP / AWS / Heroku 都可以，其他的工具包山包海，可以參考文件 &lt;a class="link" href="https://www.terraform.io/docs/providers/index.html" target="_blank" rel="noopener"
>Providers&lt;/a>&lt;/li>
&lt;li>&lt;strong>自動管理架構升級&lt;/strong>&lt;br>
架構異動時，Terraform 會自動更新或替換正確的資源，同時也可以一鍵刪除&lt;/li>
&lt;li>&lt;strong>團隊協作&lt;/strong>&lt;br>
提供多樣的解決方案，可以用官方的 Terraform Cloud 或 AWS S3 等，在團隊內共同管理&lt;/li>
&lt;li>&lt;strong>與現有架構整合&lt;/strong>&lt;br>
Terraform 提供兩種方式與既有架構整合，一是維持唯讀型態只存取資源(例如讀 AWS arn 綁定到 Lambda 上)、二是 Import 資源一並由 Terraform 管理(增加、刪除、修改)&lt;/li>
&lt;li>&lt;strong>DX 很好&lt;/strong>&lt;br>
Developer Experience 還不賴，官方的文件、教學，以及整體的設計上都很友善，錯誤也會很直接顯示哪一行的哪一部分語法錯誤，學習上 Debug 上都很容易，HashiCorp 員工有分享這是他們在 0.12 很大的修正，讓用戶更快找出錯誤是他們重視的一環&lt;/li>
&lt;/ol>
&lt;p>這次目標跟上次的 CDK 研究一樣，部署一個每五分鐘執行的 Lambda，並分佈到多個區域，CDK 教學連結 &lt;a class="link" href="https://yuanchieh.page/post/2019-01-27_aws-cdk-infrastructore-as-code/" target="_blank" rel="noopener"
>AWS-CDK教學 — Infrastructore As Code 用程式碼管理架構&lt;/a>&lt;/p>
&lt;h1 id="事前準備">事前準備&lt;/h1>
&lt;p>請先安裝 Terraform，並設定好 AWS configuration，也可以先玩過官方教學 &lt;a class="link" href="https://learn.hashicorp.com/terraform/getting-started/intro" target="_blank" rel="noopener"
>Terraform getting started&lt;/a>；
另一個很棒的參考資料 &lt;a class="link" href="https://blog.gruntwork.io/an-introduction-to-terraform-f17df9c6d180" target="_blank" rel="noopener"
>An Introduction to Terraform&lt;/a>，系列文超仔細也超實用，比官方文件還推薦，作者也有出書，有機會應該會入手&lt;/p>
&lt;h1 id="部署單區域的-lambda-與-iam-role">部署單區域的 Lambda 與 IAM Role&lt;/h1>
&lt;p>創建一個檔案，先命名為 &lt;code>main.tf&lt;/code> ，在 Terraform 中檔案分成 &lt;code>root module&lt;/code> 與 &lt;code>module&lt;/code>，沒有特別宣告是 module 則為 root module，目錄下可以有多個 root module，檔案名稱沒有進入點問題，只要結尾是 &lt;code>.tf&lt;/code> 即可&lt;/p>
&lt;p>首先第一步，先部署單一區域的 Lambda，與建立對應需要的 IAM Role，以下程式碼主要做幾件事&lt;/p>
&lt;ol>
&lt;li>宣告 aws 部署的區域&lt;/li>
&lt;li>建立新的 IAM role 命名為 iam_for_lambda，並給予調用 lambda 的權限&lt;/li>
&lt;li>建立 IAM Policy 命名為 lambda_logging，給予 Cloudwatch log 權限&lt;/li>
&lt;li>將 IAM Policy 賦予 IAM role，lambda_logging 給 iam_for_lambda&lt;/li>
&lt;li>等等 Lambda 會用到一些 node_modules，建立 Lambda layer 命名為 lambda-layer_fetch&lt;/li>
&lt;li>建立 Lambda function aws_lambda_function，綁定 lambda-layer_fetch 與執行角色 iam_for_lambda&lt;/li>
&lt;/ol>
&lt;p>寫完介紹，剛好一步對照一塊程式碼，如果對 AWS 有點熟悉的人應該可以很快理解語法，尤其是變數命名跟後台設定很雷同，所以上手相當輕鬆&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;span class="lnt">54
&lt;/span>&lt;span class="lnt">55
&lt;/span>&lt;span class="lnt">56
&lt;/span>&lt;span class="lnt">57
&lt;/span>&lt;span class="lnt">58
&lt;/span>&lt;span class="lnt">59
&lt;/span>&lt;span class="lnt">60
&lt;/span>&lt;span class="lnt">61
&lt;/span>&lt;span class="lnt">62
&lt;/span>&lt;span class="lnt">63
&lt;/span>&lt;span class="lnt">64
&lt;/span>&lt;span class="lnt">65
&lt;/span>&lt;span class="lnt">66
&lt;/span>&lt;span class="lnt">67
&lt;/span>&lt;span class="lnt">68
&lt;/span>&lt;span class="lnt">69
&lt;/span>&lt;span class="lnt">70
&lt;/span>&lt;span class="lnt">71
&lt;/span>&lt;span class="lnt">72
&lt;/span>&lt;span class="lnt">73
&lt;/span>&lt;span class="lnt">74
&lt;/span>&lt;span class="lnt">75
&lt;/span>&lt;span class="lnt">76
&lt;/span>&lt;span class="lnt">77
&lt;/span>&lt;span class="lnt">78
&lt;/span>&lt;span class="lnt">79
&lt;/span>&lt;span class="lnt">80
&lt;/span>&lt;span class="lnt">81
&lt;/span>&lt;span class="lnt">82
&lt;/span>&lt;span class="lnt">83
&lt;/span>&lt;span class="lnt">84
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-HCL" data-lang="HCL">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 指定後續資源的提供者是哪個平台的哪個區域
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># provider 沒有指定 alias 代表為預設 provider
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">provider&lt;/span> &lt;span class="s2">&amp;#34;aws&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> profile&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;default&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> region&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;us-east-1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}&lt;span class="c1">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 建立 IAM role，取名為 iam_for_lambda
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">resource&lt;/span> &lt;span class="s2">&amp;#34;aws_iam_role&amp;#34; &amp;#34;iam_for_lambda&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;iam_for_lambda&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> assume_role_policy&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="err">&amp;lt;&amp;lt;&lt;/span>&lt;span class="k">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;Statement&amp;#34;&lt;/span>&lt;span class="err">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;Action&amp;#34;: &amp;#34;sts:AssumeRole&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;Principal&amp;#34;&lt;/span>&lt;span class="err">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;Service&amp;#34;: &amp;#34;lambda.amazonaws.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;Sid&amp;#34;: &amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}&lt;span class="c1">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 建立 IAM Policy，主要給 Cloudwatch Log 權限
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">resource&lt;/span> &lt;span class="s2">&amp;#34;aws_iam_policy&amp;#34; &amp;#34;lambda_logging&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;lambda_logging&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> path&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;/&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> description&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;IAM policy for logging from a lambda&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> policy&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="err">&amp;lt;&amp;lt;&lt;/span>&lt;span class="k">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;Statement&amp;#34;&lt;/span>&lt;span class="err">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;Action&amp;#34;&lt;/span>&lt;span class="err">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;logs:CreateLogGroup&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;logs:CreateLogStream&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;logs:PutLogEvents&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">],&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;Resource&amp;#34;: &amp;#34;arn:aws:logs:*:*:*&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">resource&lt;/span> &lt;span class="s2">&amp;#34;aws_iam_role_policy_attachment&amp;#34; &amp;#34;lambda_logs&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> role&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;${aws_iam_role.iam_for_lambda.name}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> policy_arn&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;${aws_iam_policy.lambda_logging.arn}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">resource&lt;/span> &lt;span class="s2">&amp;#34;aws_lambda_layer_version&amp;#34; &amp;#34;lambda-layer_fetch&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> filename&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;./lambda_layer_payload.zip&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> layer_name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;lambda_layer_name&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> source_code_hash&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;${filebase64sha256(&amp;#34;lambda_layer_payload.zip&amp;#34;)}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> compatible_runtimes&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;nodejs10.x&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">resource&lt;/span> &lt;span class="s2">&amp;#34;aws_lambda_function&amp;#34; &amp;#34;lambda_main&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> function_name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;global-api-lantency-test&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> filename&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;./lambda_payload.zip&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> handler&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;index.handler&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> runtime&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;nodejs10.x&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> role&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;${aws_iam_role.iam_for_lambda.arn}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> source_code_hash&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;${filebase64sha256(&amp;#34;lambda_payload.zip&amp;#34;)}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> layers&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;${aws_lambda_layer_version.lambda-layer_fetch.arn}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> publish&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kt">true&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">environment&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> variables&lt;/span> &lt;span class="o">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> REGION&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;us-east-1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> SLACK_URL&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;https://hooks.slack.com/services/.....&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="provider">Provider&lt;/h3>
&lt;p>指定資源是套用在哪個平台，目前是指定在 us-east-1 AWS 上，如果沒有指定 &lt;code>alias&lt;/code> 則代表是預設的 provider&lt;/p>
&lt;h3 id="resource">Resource&lt;/h3>
&lt;p>命名的方式是&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-HCL" data-lang="HCL">&lt;span class="line">&lt;span class="cl">&lt;span class="k">resource&lt;/span> &lt;span class="k">資源類型&lt;/span> &lt;span class="k">資源名稱&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">資源參數&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>資源參數對應資源類型，可以從文件中找範例與定義的方式，資源的定義依賴於 Provider 平台的不同，可以指定 &lt;code>provider&lt;/code>，不指定則用預設&lt;/p>
&lt;p>除了個別的資源定義外，像有些資源會相依，例如 Lambda 要綁定特定的 IAM Role，注意到這邊的寫法是&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-HCL" data-lang="HCL">&lt;span class="line">&lt;span class="cl">&lt;span class="k">resource&lt;/span> &lt;span class="s2">&amp;#34;aws_lambda_function&amp;#34; &amp;#34;lambda_main&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> role&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;${aws_iam_role.iam_for_lambda.arn}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">....&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>要引用其他資源的參數，需要用&lt;code>&amp;quot;${資源類型.資源名稱.arn}&amp;quot;&lt;/code>，arn 是 AWS 用來識別資源的全域 ID，透過這樣的方式就能夠綁定資源，這邊我指定要用 Lambda 的 Execution Role 是 iam_for_lambda 這個 Role。&lt;br>
另外為了效率，定義的資源會並行建立，但有些資源有相依性，Terraform 會自動處理相依性，所以上述的資源理論上要 Policy &amp;gt; Role &amp;gt; Lambda Layer &amp;gt; Lambda，但我們不用宣告 Terraform 會自行處理；
但有時候相依性不明顯或是有特殊需求，可以顯示宣告 &lt;code>depends_on&lt;/code>。&lt;/p>
&lt;p>Lambda Function 建立完成後，如果只是要單純更改 Lambda 內容而不調整架構，可以宣告&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-HCL" data-lang="HCL">&lt;span class="line">&lt;span class="cl">&lt;span class="k">resource&lt;/span> &lt;span class="s2">&amp;#34;aws_lambda_function&amp;#34; &amp;#34;lambda_main&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> source_code_hash&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;${filebase64sha256(&amp;#34;lambda_payload.zip&amp;#34;)}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>source_code_hash&lt;/code> 是指說如果 hash 值改變就更新 Lambda 內容，而 &lt;code>filebase64sha256()&lt;/code> 是 Terraform 的內建函示，自動用 sha 256 算出檔案 hash 值並用 base64 編碼&lt;/p>
&lt;p>題外話，Lambda 的 zip file 記得解壓縮後不要有額外的資料夾，不然會失敗，正確應該要是&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="line">&lt;span class="cl">--- lambda.zip
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> |--- index.js
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h1 id="部署架構">部署架構&lt;/h1>
&lt;p>編寫好架構，此時要調用 Terraform CLI 來部署架構
首先初始化環境與載入需要的執行資源&lt;/p>
&lt;blockquote>
&lt;p>$ terraform init&lt;/p>
&lt;/blockquote>
&lt;p>一開始 Terraform 並不知道建立的 Provider 是誰，直到初始化才會下載對應的 Library，放在專案路徑底下的 &lt;code>.terraform&lt;/code> 資料夾下&lt;/p>
&lt;p>成功後，就可以部署架構了&lt;/p>
&lt;blockquote>
&lt;p>$ terraform apply&lt;/p>
&lt;/blockquote>
&lt;p>此時 Terraform 會列出更動的資源，&lt;code>+&lt;/code> 代表需要新建的資源、&lt;code>-&lt;/code>代表會被刪除的資源、&lt;code>~&lt;/code>代表會被更新的資源，注意資源更新可是刪除舊的資源部署新的資源，依照各家 provider 的 API 而有所不同，需要特別留意
如果確認就輸入 &amp;ldquo;yes&amp;rdquo;，等 Terraform 幫忙部署&lt;/p>
&lt;p>這樣就完成了，後續有什麼調整就重複 &lt;code>$ terraform apply&lt;/code> 步驟，可以到 AWS 後台確認資源的建立狀況&lt;/p>
&lt;h1 id="加上-cloudwatch">加上 Cloudwatch&lt;/h1>
&lt;p>這一段雷同，補上 cloudwatch event rule / cloudwatch event targe，最後別忘了要加綁定 lambda permission 不然觸發 Lambda 會失敗&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-HCL" data-lang="HCL">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># add cloudwatch event
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">resource&lt;/span> &lt;span class="s2">&amp;#34;aws_cloudwatch_event_rule&amp;#34; &amp;#34;every_five_minutes&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;routine-api-request&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> description&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;Routinely call global api lantency test&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> schedule_expression&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;rate(5 minutes)&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">resource&lt;/span> &lt;span class="s2">&amp;#34;aws_cloudwatch_event_target&amp;#34; &amp;#34;api_request&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> rule&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;${aws_cloudwatch_event_rule.every_five_minutes.name}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> target_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;CallApiRequest&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> arn&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;${aws_lambda_function.lambda_main.arn}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}&lt;span class="c1">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">resource&lt;/span> &lt;span class="s2">&amp;#34;aws_lambda_permission&amp;#34; &amp;#34;allow_cloudwatch_to_call_check_api&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> statement_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;AllowExecutionFromCloudWatch&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> action&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;lambda:InvokeFunction&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> function_name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;${aws_lambda_function.lambda_main.function_name}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> principal&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;events.amazonaws.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> source_arn&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;${aws_cloudwatch_event_rule.every_five_minutes.arn}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h1 id="import-現有的-iam-role">Import 現有的 IAM Role&lt;/h1>
&lt;p>回過頭說一下之前採用 AWS CDK 的最大問題，當初研究時沒有看到 AWS CDK 與現有架構的整合，這導致公司要採用需要很大的決心，或是只能用在測試或新的環境建設，沒有辦法 graceful 轉移，這點我覺得對於要導入新技術來說，有點麻煩，尤其是架構這麼重要的地方；&lt;/p>
&lt;p>另一點是角色的權限管理，公司都會有針對不同的職位給予不同的權限，AWS CDK 預設就要 CreateRole 等權限，基本上很難直接要到這麼高的權限，也是當初要在公司專案嘗試 AWS CDK 最大失敗的原因&lt;/p>
&lt;p>Terraform 現行支援 &lt;code>import&lt;/code> 既有的資源，但是資源內容要自己填寫，未來宣稱會支援自動載入內容；&lt;br>
&lt;code>existed_role&lt;/code> 是我預先在 AWS 創建的 IAM Role，權限跟上面的 &lt;code>iam_for_lambda&lt;/code> 一樣，記得要先在設定檔宣告，接著執行指令就完成了，之後 &lt;code>terraform destroy&lt;/code> 也會一並刪除 (需要留意)&lt;/p>
&lt;blockquote>
&lt;p>$ terraform import aws_iam_role.existed_role existed_role&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-HCL" data-lang="HCL">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># existed iam role
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">resource&lt;/span> &lt;span class="s2">&amp;#34;aws_iam_role&amp;#34; &amp;#34;existed_role&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;existed_role&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> assume_role_policy&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="err">&amp;lt;&amp;lt;&lt;/span>&lt;span class="k">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;Statement&amp;#34;&lt;/span>&lt;span class="err">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;Action&amp;#34;: &amp;#34;sts:AssumeRole&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;Principal&amp;#34;&lt;/span>&lt;span class="err">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;Service&amp;#34;: &amp;#34;lambda.amazonaws.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;Sid&amp;#34;: &amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">EOF&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h1 id="variables---抽離參數">Variables - 抽離參數&lt;/h1>
&lt;p>目前的參數都是寫死的，例如說部署的區域、Lambda 名稱等，Terraform 支援 variable 定義，可以有以下幾種類型&lt;/p>
&lt;ol>
&lt;li>string&lt;/li>
&lt;li>boolean&lt;/li>
&lt;li>number&lt;/li>
&lt;li>set&lt;/li>
&lt;li>map&lt;/li>
&lt;li>object (等同於 map，但會蓋過 map)&lt;/li>
&lt;li>tuple&lt;/li>
&lt;/ol>
&lt;p>如果要在參數使用變數的話，必須要先在資源檔 &lt;code>.tf&lt;/code> 宣告&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-HCL" data-lang="HCL">&lt;span class="line">&lt;span class="cl">&lt;span class="k">variable&lt;/span> &lt;span class="s2">&amp;#34;image_id&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> type&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">string&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> default&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;default 值&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> description&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;The id of the machine image (AMI) to use for the server.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>type 必填，但是 default 跟 description 不用，當沒有 default 且後續變數沒有賦值的話，在 &lt;code>&amp;gt;$terraform apply&lt;/code> 時會中斷要求輸入&lt;/p>
&lt;p>在資源定義檔上，可以採用 &lt;code>var.變數名稱&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-HCL" data-lang="HCL">&lt;span class="line">&lt;span class="cl">&lt;span class="k">provider&lt;/span> &lt;span class="s2">&amp;#34;aws&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> profile&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;default&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> region&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">var&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">image_id&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接著，透過以下幾種方式賦值給 variable&lt;/p>
&lt;ol>
&lt;li>環境變數
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-HCL" data-lang="HCL">&lt;span class="line">&lt;span class="cl">&lt;span class="n">$export TF_VAR_image_id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">ami&lt;/span>&lt;span class="err">-&lt;/span>&lt;span class="k">abc123&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">$export TF_VAR_availability_zone_names&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="err">&amp;#39;&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;us-west-1b&amp;#34;,&amp;#34;us-west-1d&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>&lt;code>terraform.tfvars&lt;/code> 檔案中
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-HCL" data-lang="HCL">&lt;span class="line">&lt;span class="cl">&lt;span class="n">image_id&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;ami-abc123&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">availability_zone_names&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;us-west-1b&amp;#34;,&amp;#34;us-west-1d&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>&lt;code>terraform.tfvars.json&lt;/code> 檔案中
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;image_id&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;ami-abc123&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nt">&amp;#34;availability_zone_names&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;us-west-1a&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;us-west-1c&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>&lt;code>*.auto.tfvars&lt;/code> 或是 &lt;code>*.auto.tfvars.json&lt;/code>，順序按照檔名&lt;/li>
&lt;li>在 CLI 執行時指定 &lt;code>-var&lt;/code> &lt;code>-var-file&lt;/code>
&lt;blockquote>
&lt;p>$terraform apply -var=&amp;ldquo;image_id=ami-abc123&amp;rdquo;&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>如果有同樣的變數名稱，按照上面的規則順序後者蓋過前者，例如 &lt;code>-var&lt;/code> 會蓋過其他檔案的宣告&lt;/p>
&lt;h1 id="output---輸出參數">Output - 輸出參數&lt;/h1>
&lt;p>對於 root module 來說，設定 output 會在 &lt;code>&amp;gt; $terraform apply&lt;/code> 時打印，例如說 EC2 Instance 的 public DNS等；
對 module 來說，Output 等同於 function 的 return value，決定哪些資源讓外部讀取&lt;/p>
&lt;p>在範例程式的目錄下有獨立的 &lt;code>output.tf&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-HCL" data-lang="HCL">&lt;span class="line">&lt;span class="cl">&lt;span class="k">output&lt;/span> &lt;span class="s2">&amp;#34;lambda-arn&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">aws_lambda_function&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">lambda_main&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">arn&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">output&lt;/span> &lt;span class="k">輸出參數名餐&lt;/span> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n"> value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">資源類別&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">資源命名&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">資源屬性&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>會在 apply 成功後打印出來&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="line">&lt;span class="cl">Apply complete! Resources: 2 added, 0 changed, 0 destroyed.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Outputs:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">lambda-arn = arn:aws:lambda:us-east-1:.....
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h1 id="state---terraform-如何掌管架構的更動">State - Terraform 如何掌管架構的更動&lt;/h1>
&lt;p>當架構異動的時候，Terraform 如何知道前後架構的差異呢？
每次在執行 &lt;code>$ terraform plan&lt;/code> 時，專案目錄底下有 &lt;code>terraform.tfstate&lt;/code> 檔案，用 JSON 描述架構中的所有資源，每當下次執行 &lt;code>$ terraform plan&lt;/code> 時，Terraform 會根據 tfstate 中的資源 ID 取得最新的資訊，接著與描述檔做 diff 決定哪部分資源要更新&lt;/p>
&lt;p>當我們要跨團隊協作時，就需要把 terraform 描述檔 + terraform.tfstate 與團隊共享，此時會有有三個要素&lt;/p>
&lt;ol>
&lt;li>&lt;strong>共享檔案與版本控制&lt;/strong>&lt;br>
檔案共享是最基本的協作必備條件，同時將程式碼做版本控制也是很必要的功能&lt;/li>
&lt;li>&lt;strong>Lock 機制&lt;/strong>&lt;br>
當共享了之後，Lock 就變成是必須考量的因素，避免團隊同時多人同步修改，造成前後衝突的狀況&lt;/li>
&lt;li>&lt;strong>獨立不同的 state 狀態&lt;/strong>&lt;br>
在實際應用上，可能會有 development / staging / production 不同環境，希望共用程式碼建立雷同的架構，但又因為環境不同希望有不同的配置，例如機器大小或 VPC 等，此時就需要考量如何獨立不同環境&lt;/li>
&lt;/ol>
&lt;p>在跨同團隊協作很容易想到 &lt;code>git&lt;/code> ，但嚴格來說 git 只能滿足第一點，所以在 Terraform 可以指定不同的 state 管理方式，除了官方的 Terraform Cloud，可以採用 &lt;code>AWS S3 + DynamoDB&lt;/code> 達到上述的條件，並附帶版本控制，再之後會更詳細的描述操作流程，詳情可以參考 &lt;a class="link" href="https://blog.gruntwork.io/how-to-manage-terraform-state-28f5697e68fa" target="_blank" rel="noopener"
>How to manage Terraform state&lt;/a>&lt;/p>
&lt;h1 id="結語">結語&lt;/h1>
&lt;p>就這樣完成了單區域的 Lambda 部署與最基本的 Terraform 學習，以下是這次教學的程式碼
&lt;a class="link" href="https://github.com/sj82516/terraform-investigation/commit/9106731fcb895c4aa31a1b95670d627fa60e4a4a" target="_blank" rel="noopener"
>terraform-investigation&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://yuanchieh.page/post/2019-11-04_try-terraform-2/" target="_blank" rel="noopener"
>下一篇&lt;/a>將整個架構模組化，並一鍵部署多個區域&lt;/p></description></item><item><title>Route53 Latency-Based Routing 機制 — DNS 如何評估延遲</title><link>https://yuanchieh.page/posts/2019/2019-04-29-route53-latency-based-routing-%E6%A9%9F%E5%88%B6-dns-%E5%A6%82%E4%BD%95%E8%A9%95%E4%BC%B0%E5%BB%B6%E9%81%B2/</link><pubDate>Mon, 29 Apr 2019 00:18:14 +0000</pubDate><guid>https://yuanchieh.page/posts/2019/2019-04-29-route53-latency-based-routing-%E6%A9%9F%E5%88%B6-dns-%E5%A6%82%E4%BD%95%E8%A9%95%E4%BC%B0%E5%BB%B6%E9%81%B2/</guid><description>&lt;p>前陣子做全球不同地區 API Server 的部署，希望用戶基於延遲性選擇最靠近的 API Server，透過 &lt;a class="link" href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-to-api-gateway.html" target="_blank" rel="noopener"
>Route53 + API Gateway&lt;/a> 實作非常簡單。&lt;/p>
&lt;p>但量測延遲性，理論上只能由 Client 向多個 Server 發送，最後評比整段 Http Request 完成的時間；&lt;br>
Route53 身為 DNS Server，如果是從 DNS Server 去打 Server，那量測的結果應當是 Route53 到 Server 的延遲，而不能代表 Client 到 Server；&lt;/p>
&lt;p>好比說 User 在台灣，Route53 Server 在美國，Server1 在美西，Server2 在東京，那從 Route53 角度一定是美西的 Server1 比較近，但對 User 來說會是日本的 Server2 比較近才是；&lt;br>
又如果說 Route53 是全球部署，那Route53 又如何決定 User 要連到哪個地區的 DNS Server ? &lt;br>
又例如說 CDN，同樣會遇到要去哪個 Local CDN Server 比較快的問題？&lt;/p>
&lt;p>以下是研究這個問題的過程。&lt;/p>
&lt;h3 id="how-amazon-route-53-uses-edns0-to-estimate-the-location-of-auser">How Amazon Route 53 Uses EDNS0 to Estimate the Location of a User&lt;/h3>
&lt;p>參考&lt;a class="link" href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-edns0" target="_blank" rel="noopener"
>官方文件&lt;/a>，Route53 支援 DNS protocol 額外擴充 EDNS0 中的edns-client-subnet。&lt;/p>
&lt;p>DNS 技術發展於 1980 年代，當時 protocol 設計只有留 512 bytes 可以夾帶資訊，但隨著時間演進，人們希望加入更多的功能，例如說更多的 IPv6、[DNSSEC](&lt;a class="link" href="https://medium.com" target="_blank" rel="noopener"
>https://medium.com&lt;/a>&lt;/p>
&lt;p>&lt;strong>edns-client-subnet&lt;/strong> 主要是讓 client 再發起 DNS resolve 時可以在 query 中夾帶自己 IP 的 subnet，讓 DNS Server 可以知道 client 確切的 IP 來源而不會再 Recursive 解析過程中被置換，更詳細解釋於下一節；&lt;br>
如果 client 不支援 edns-client-subnet，則 Route53 會拿 IP當作來源位置判斷。&lt;/p>
&lt;blockquote>
&lt;p>Route53 是透過 IP 判斷用戶的位置，並用此位置當作量測的基準，Geolocation / Latency based 都是如此；&lt;br>
而 IP 位置來源優先使用 edns-client-subnet，其次用 source IP。&lt;/p>
&lt;/blockquote>
&lt;h3 id="edns-client-subnet-ecs">edns-client-subnet (ECS)&lt;/h3>
&lt;p>摘要一些 RFC 內容&lt;/p>
&lt;p>&lt;a class="link" href="https://tools.ietf.org/html/rfc7871" target="_blank" rel="noopener"
>&lt;strong>RFC 7871 - Client Subnet in DNS Queries&lt;/strong>&lt;/a>&lt;/p>
&lt;p>DNS 查詢的方式是一層一層的，從最頂級的域名一路向下，例如說 hello.example.com，就會從 .com Nameserver → example.com Nameserver 逐步查詢。&lt;/p>
&lt;p>Client 會透過 Stub Resolver (可理解一個 DNS Agent)，透過 Intermediate Nameserver 向 Authoritative Nameserver (握有 DNS zones 域名區域) 發起請求。&lt;/p>
&lt;p>其中 Intermediate Nameserver 有兩種：&lt;/p>
&lt;ol>
&lt;li>Forwarding Resolver：不會遞迴解析，僅會傳遞給下一個 Recursive Resolver。&lt;/li>
&lt;li>Recursive Resolver：遞迴 domain chain 直到域名解析完成，會透過 cache 快速返回查詢。&lt;/li>
&lt;/ol>
&lt;p>目前來說，Recursive Resolver 使用日益增加，因為集中化管理有幾個優點 &lt;code>cache 更多資訊&lt;/code> 、&lt;code>審查用戶的 DNS查詢&lt;/code> ，但是傳統的 Recursive Resolver 在遞迴查詢時，會將 Source IP 改成自己的 IP而不是 Client 的 IP，但 Recursive Resolver 跟 Client 可能隔很遠(網路拓墣上的距離)；&lt;br>
如果此時 Authoritative Nameserver 希望解析 Client IP 提供量身定做的 DNS Answer (Tailored Response)，就沒有辦法，因此制定 edns-subset-client 解決此問題。&lt;/p>
&lt;h4 id="option-format">Option Format&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="line">&lt;span class="cl">+0 (MSB) +1 (LSB)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> +---+---+---+---+---+---+---+---+---+---+---+---+---+
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 0: | OPTION-CODE |
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> +---+---+---+---+---+---+---+---+---+---+---+---+---+
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 2: | OPTION-LENGTH |
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> +---+---+---+---+---+---+---+---+---+---+---+---+---+
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 4: | FAMILY |
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> +---+---+---+---+---+---+---+---+---+---+---+---+---+
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 6: | SOURCE PREFIX-LENGTH | SCOPE PREFIX-LENGTH |
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> +---+---+---+---+---+---+---+---+---+---+---+---+---+
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 8: | ADDRESS... |
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> +---+---+---+---+---+---+---+---+---+---+---+---+---+
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>edns-subset-client protocol 是基於 &lt;a class="link" href="https://tools.ietf.org/html/rfc6891" target="_blank" rel="noopener"
>EDNS0&lt;/a> 制定，以下是他的 package 內容：&lt;/p>
&lt;ol>
&lt;li>OPTION-CODE&lt;br>
兩個八位元組，固定是 &lt;code>0x00 0x08&lt;/code>&lt;/li>
&lt;li>OPTION-LENGTH&lt;br>
兩個八位元組，代表 payload 長度&lt;/li>
&lt;li>FAMILY&lt;br>
兩個八位元組，代表 address 的 family (IANA標準)，目前支援 IPv4跟 IPv6&lt;/li>
&lt;li>SOURCE PREFIX-LENGTH&lt;br>
Address 遮罩，Client 用來指定查詢的 IP 遮罩&lt;/li>
&lt;li>SCOPE PREFIX-LENGTH&lt;br>
同樣是 Address 遮罩，但是是由 Response 表示 Address 覆蓋範圍。&lt;/li>
&lt;/ol>
&lt;p>SOURCE PREFIX-LENGTH 跟 SCOPE PREFIX-LENGTH 這兩個參數相對比較重要&lt;/p>
&lt;ol>
&lt;li>當 Client 或 Stub Resolver 發起 name resolve 時，會指定 &lt;code>Address&lt;/code> 與 &lt;code>SOURCE PREFIX-LENGTH&lt;/code>，&lt;code>SOURCE PREFIX-LENGTH&lt;/code> 算是希望&lt;code>保留 Client IP 部分隱私，不見得要全部都送往 Nameserver&lt;/code>；&lt;br>
但 &lt;code>SCOPE PREFIX-LENGTH&lt;/code> 必須設為 0 因為這是用在 Response 上&lt;/li>
&lt;li>當 Recursive Resolver 收到時，會透 &lt;code>SOURCE PREFIX-LENGTH&lt;/code> 遮罩查詢 Cache，如果有則返回；沒有則繼續查詢，此時遞迴查詢的 &lt;code>SOURCE PREFIX-LENGTH&lt;/code> 僅可小於等於來源查詢的 &lt;code>SOURCE PREFIX-LENGTH&lt;/code>&lt;/li>
&lt;li>Authoritative Nameserver 如果回傳的 &lt;code>SCOPE PREFIX-LENGTH&lt;/code> 小於 &lt;code>SOURCE PREFIX-LENGTH&lt;/code>，代表不需用提供這麼多 bits；&lt;br>
反之 &lt;code>SCOPE PREFIX-LENGTH&lt;/code> &amp;gt; &lt;code>SOURCE PREFIX-LENGTH&lt;/code>，則代表需要提供更多得 bits 才能得到更精準的 Answer。&lt;/li>
&lt;li>Authoritative Nameserver 處理 Cache 時要多加注意，不可以有 Prefix overlapping ，避免匹配到短的 prefix 回傳錯誤的 RRsets；&lt;br>
例如說原本的 cache 是 1.2.0/20 A，但此時多加了 1.2.3/24 B，就需要拆成 1.2.0/23, 1.2.2/24, 1.2.4/22, 1.2.8/21 A，1.2.3/24 B，避免疊合。&lt;/li>
&lt;/ol>
&lt;h4 id="資安風險">資安風險&lt;/h4>
&lt;ol>
&lt;li>生日攻擊&lt;br>
如果駭客向 Intermediate Nameserver 發送大量的假 DNS Answer，如果不小心被吻合到，Intermediate Nameserver 就會回傳被釣魚的IP，這個問題在原本的 DNS 就會出現。&lt;br>
 → Intermediate Nameserver 必須對 DNS Answer 做欄位檢查，最好支援 DNSSEC 減輕問題發生機率&lt;/li>
&lt;li>Cache 污染&lt;br>
支援 ECS 後，Cache 機制變得更加複雜，會需要基於 FAMILY / SCOPE PREFIX-LENGTH / ADDRESS Cache，造成 Memory 用量大增；&lt;br>
如果駭客運用這一點，用洪水攻擊製造大量不容易命中 Cache 的查詢，對 DNS Nameserver 做 DDos 攻擊。&lt;br>
 → Nameserver 必須自行做好評估&lt;/li>
&lt;/ol>
&lt;h4 id="示範案例">示範案例&lt;/h4>
&lt;p>Spec 中有個示範案例&lt;/p>
&lt;p>1. Stub Resolver (SR)，IP位置是 2001:0db8:fd13:4231:2112:8a2e:c37b:7334，準備透過 Recursive Resolver (RNS) 查詢 &lt;a class="link" href="http://www.example.com" target="_blank" rel="noopener"
>www.example.com&lt;/a>&lt;/p>
&lt;p>2. RNS 支援 ECS，查詢 &lt;a class="link" href="http://www.example.com" target="_blank" rel="noopener"
>www.example.com&lt;/a> 是否在 cache中，沒有則開始查詢&lt;/p>
&lt;p>3. RNS 向 root Nameserver .com 查詢，向 root Nameserver 查詢不需要夾帶 ECS 選項&lt;/p>
&lt;p>4. 接著 RNS 準備去找 .example.com Authoritative Nameserver (ANS)&lt;/p>
&lt;p>5. RNS 要傳遞的封包，必須加入 ECS 選項&lt;/p>
&lt;ul>
&lt;li>OPTION-CODE: 8&lt;/li>
&lt;li>OPTION-LENGTH: 0x0b，固定 4 bytes + 7 bytes 的 Address&lt;/li>
&lt;li>FAMILY: 0x00 0x02，代表 IPv6&lt;/li>
&lt;li>SOURCE PREFIX-LENGTH: 0x38，遮罩代表 /56 bits&lt;/li>
&lt;li>SCOPE PREFIX-LENGTH: 0x00，這是 Answer 用的&lt;/li>
&lt;li>ADDRESS: 0x20 0x01 0x0d 0xb8 0xfd 0x13 0x42，也就是前 56 bits&lt;/li>
&lt;/ul>
&lt;p>6. ANS 收到後，產生結果(Tailored Response)回傳，其餘內容相同&lt;/p>
&lt;ul>
&lt;li>SCOPE PREFIX-LENGTH: 0x30, 代表 /48&lt;/li>
&lt;/ul>
&lt;p>7. RNS 收到後，比對 FAMILY, SOURCE PREFIX-LENGTH 和ADDRESS，如果不吻合則拋棄&lt;/p>
&lt;p>8. RNS 基於 ADDRESS, SCOPE PREFIX-LENGTH 和 FAMILY 做 cache&lt;/p>
&lt;p>9. RNS 回傳結果給 SR，此時不需要 ECS 選項&lt;/p>
&lt;h3 id="透過-dig檢驗">透過 dig 檢驗&lt;/h3>
&lt;p>dig 支援 edns-client-subnet 參數，藉此觀察 dns 回傳的 A record，指令為 &lt;code>dig [@8](http://twitter.com/8 &amp;quot;Twitter profile for @8&amp;quot;).8.8.8 {測試 domain name} +subnet={測試的 ip}&lt;/code> ，網路上很多資料是使用 &lt;code>+client={測試 ip}&lt;/code> ，我實測是用 &lt;code>+subnet&lt;/code> 才可以。&lt;/p>
&lt;p>前面提到的 &lt;code>SCOPE PREFIX-LENGTH&lt;/code> ，Route53 回傳 24，也就是最多提供 24 bits 的 Address 就可以取得最佳解。&lt;/p>
&lt;p>測試的 domain 是公司內部透過 Route53 與 API Gateway 架設，不方便公開，但透過 VPN 取得不同區域的 ip，例如日本、印度、加拿大、阿根廷等地，放入 subnet 參數後，DNS 回傳的 ANSWER 確實跟著地區而改動；&lt;br>
有點弔詭的是巴西不走國內反而是到法國 Frankfurt的伺服器，而阿根廷是到巴西 São Paulo的伺服器；&lt;br>
GeoIP 查詢透過 &lt;a class="link" href="https://www.maxmind.com/en/geoip-demo" target="_blank" rel="noopener"
>Maxmind&lt;/a>，他有每日查詢上線，是綁定 IP限制。&lt;/p></description></item><item><title>Http persistent connection 研究與 proxy — server keep-alive timeout 不一致的 502 錯誤</title><link>https://yuanchieh.page/posts/2019/2019-04-08-http-persistent-connection-%E7%A0%94%E7%A9%B6%E8%88%87-proxy-server-keep-alive-timeout-%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84-502-%E9%8C%AF%E8%AA%A4/</link><pubDate>Mon, 08 Apr 2019 23:46:01 +0000</pubDate><guid>https://yuanchieh.page/posts/2019/2019-04-08-http-persistent-connection-%E7%A0%94%E7%A9%B6%E8%88%87-proxy-server-keep-alive-timeout-%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84-502-%E9%8C%AF%E8%AA%A4/</guid><description>&lt;p>架構上使用 elb 當作 load balancer proxy，後端接 nodejs api server，但是偶爾拋出 502 錯誤，elb log 顯示該次連線沒有進到 api server，麻煩的是機器 health check 正常，絕大多數的 api 測試也都正確，錯誤不太好復現，直到後來才發現是 proxy 與 api server 在 persistent connection 的 time-out 機制有所不同。&lt;/p>
&lt;p>以下是研究 http 1.0 / 1.1 keep-alive / persistent connection 機制，並重新復現與解決問題。&lt;/p>
&lt;h3 id="persistent-connection-簡介">persistent connection 簡介&lt;/h3>
&lt;p>&lt;img src="https://yuanchieh.page/post/img/1__TCGmEtiKtghxQ6yG28J2Sg.png"
loading="lazy"
>&lt;/p>
&lt;p>&lt;a class="link" href="https://en.wikipedia.org/wiki/HTTP_persistent_connection#/media/File:HTTP_persistent_connection.svg" target="_blank" rel="noopener"
>https://en.wikipedia.org/wiki/HTTP_persistent_connection#/media/File:HTTP_persistent_connection.svg&lt;/a>&lt;/p>
&lt;p>參考自&lt;a class="link" href="https://en.wikipedia.org/wiki/HTTP_persistent_connection" target="_blank" rel="noopener"
>維基百科&lt;/a>，persistent connection 主要是希望在短時間內有多個 http request 時，可以重新利用 tcp connection，而不是每次都重新建立 tcp連線，降低 tcp handshaking 時間等開銷。&lt;/p>
&lt;p>在 &lt;strong>http 1.0&lt;/strong> 並沒有正式支援且默認關閉，但是蠻大多數的 http agent 都有支援，在 header 註明 &lt;code>Connection: keep-alive&lt;/code> ，如果 server 也支援會把 header Connection 再次回傳；&lt;br>
直到 client 或 server 決定斷線才會發送 &lt;code>Connection: close&lt;/code> 斷開連線。&lt;/p>
&lt;p>在 &lt;strong>http 1.1&lt;/strong> 默認開啟，如果關閉 persistent connection 則必須主動在 http request 夾帶 &lt;code>Connection: close&lt;/code> 。&lt;/p>
&lt;p>在 reverse proxy 中或是 application server 都可以設置 keep-alive timeout，決定 server 在閒置多少秒數後沒有收到新的 http request 就主動斷開連線，以下透過 wireshark 實際觀察 persistent connection。&lt;/p>
&lt;p>server.js 的程式碼很簡單&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-js" data-lang="js">&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">http&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">require&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;http&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">const&lt;/span> &lt;span class="nx">server&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nx">http&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">createServer&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="nx">req&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">res&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">res&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">end&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">server&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">listen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3000&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="http-10--client--server">http 1.0 ： client ← → server&lt;/h3>
&lt;p>如果直接使用 nodejs http module或是其他二次開發的模組，預設是採用 http 1.1 且不能修改，此時必須使用更底層的 net 模組發送 http 1.0 request&lt;/p>
&lt;p>&lt;img src="https://yuanchieh.page/post/img/1____VxpaLipngwfWOh74Ye__CA.jpeg"
loading="lazy"
>&lt;/p>
&lt;p>Server 很明確知道此次 connection 沒有要復用所以就可以直接斷開連結。&lt;/p>
&lt;h3 id="http-11-client--server">http 1.1: client ← → server&lt;/h3>
&lt;p>http 1.1 request 預設會使用 persistent connection，程式碼把上面的 &lt;code>Http/1.0&lt;/code> 改成 &lt;code>Http/1.1&lt;/code> 即可，觀察 wireshark server 的回應就有所不同&lt;/p>
&lt;p>&lt;img src="https://yuanchieh.page/post/img/1__4g8eFUFSBgKKQZjqSVsBkA.jpeg"
loading="lazy"
>&lt;/p>
&lt;p>觀察到 http 1.1 預設支援 persistent connection，所以 server 會等到 keep-alive timeout (nodejs 8.0 後預設 5秒)才會斷開連結，從封包顯示是由 client 斷開連結。&lt;/p>
&lt;p>為什麼 client 會主動關閉而沒有走 persistent connection 呢？&lt;/p>
&lt;h3 id="http-11-keep-alive">http 1.1: keep-alive&lt;/h3>
&lt;p>在 nodejs中，http request 如果要使用 keep-alive，&lt;code>必須透過 http agent 發送&lt;/code>，http agent 會生成 socket pool 並控制 socket 的復用與關閉時機；&lt;br>
如果不使用 http agent，即使 header 或預設支援 keep-alive，每個 request 結束後client都會主動發送 [FIN,ACK] 斷開連結。&lt;/p>
&lt;p>&lt;img src="https://yuanchieh.page/post/img/1__HPu__O06NHGGpqpfwTg__pYg.jpeg"
loading="lazy"
>&lt;/p>
&lt;p>觀察到 tcp 少了一次完整的交握 (建立與結束)，省了 9 個 tcp packets 來回的時間。&lt;/p>
&lt;h3 id="http-11-keep-alive-timeout">http 1.1: keep-alive timeout&lt;/h3>
&lt;p>預設 server 是五秒，那如果 client 第二個 request 超過五秒發送會發生什麼事？&lt;/p>
&lt;p>&lt;img src="https://yuanchieh.page/post/img/1__FcolIW8__fD4jCIwMu6oWyw.jpeg"
loading="lazy"
>&lt;/p>
&lt;p>根據觀察結果，在第一個 request 完成後，每隔一秒(秒數可調整)會從 client 發送 &lt;a class="link" href="http://www.tldp.org/HOWTO/html_single/TCP-Keepalive-HOWTO/#whatis" target="_blank" rel="noopener"
>[ TCP Keep-Alive ]&lt;/a> 封包，五秒到 server 主動斷開連線；&lt;br>
下一個 http request 就必須重新建立 tcp 連線。&lt;/p>
&lt;blockquote>
&lt;p>小結：&lt;br>
沒有走 persistent connection，通常是由 server close connection，因為 server 決定 response 的長度；&lt;br>
但是 persistent connection 下，可能由 client 或 server 任一者 close connection，不過新的 request 還是由 client 發起。&lt;/p>
&lt;/blockquote>
&lt;p>現在加入 Nginx Reverse Proxy，模擬幾種情況&lt;/p>
&lt;h3 id="nginx-proxy不使用-keepalive">Nginx Proxy — 不使用 KeepAlive&lt;/h3>
&lt;p>從最基本的設定檔開始，最單純轉發的動作&lt;/p>
&lt;p>接著用 docker 執行&lt;/p>
&lt;p>docker run -v /Users/zhengyuanjie/Desktop/Nodejs/persistent-connection/ka_nginx.conf:/etc/nginx/nginx.conf -it -p 8080:80 nginx&lt;/p>
&lt;p>目前分成兩段 &lt;code>client &amp;lt;---&amp;gt; nginx &amp;lt;---&amp;gt; nodejs server&lt;/code>&lt;/p>
&lt;p>分別查看 wireshark 封包&lt;/p>
&lt;p>&lt;img src="https://yuanchieh.page/post/img/1__fcMFyqRZQpyVIH3F2iBIQg.jpeg"
loading="lazy"
>
&lt;img src="https://yuanchieh.page/post/img/1__F9tpw9gqLudFmq65vjZ6zA.jpeg"
loading="lazy"
alt="左圖為 client ← → nginx / 右圖為 nginx ← → server"
>
左圖為 client ← → nginx / 右圖為 nginx ← → server&lt;/p>
&lt;p>因為 nginx keep-alive 設置 timeout 為 65秒，所以 &lt;code>client &amp;lt;---&amp;gt; nginx&lt;/code> 處於 persistent connection；&lt;br>
但是 &lt;code>nginx &amp;lt;---&amp;gt; server&lt;/code> 這段是每次 request 都重新建立，預設到 server 這段 nginx 不會建立 persistent connection。&lt;/p>
&lt;h3 id="nginx-proxy開啟keepalive-且-timeout-大於-nodejsserver">Nginx Proxy — 開啟KeepAlive 且 timeout 大於 nodejs server&lt;/h3>
&lt;p>簡單修改一下 nginx conf，讓 &lt;code>nginx &amp;lt;---&amp;gt; server&lt;/code> 這段也走 persistent connection&lt;/p>
&lt;p>&lt;img src="https://yuanchieh.page/post/img/1__BAM9__7LQjtNIRDSBLn0SOQ.jpeg"
loading="lazy"
>
&lt;img src="https://yuanchieh.page/post/img/1__8pTNIDN7hnuI6uFToEdVZg.jpeg"
loading="lazy"
>&lt;/p>
&lt;p>觀察到一個現象是 client ← → nginx 已經由 client 主動斷開連線，但是 nginx 到 server 卻要等到其中一者 timeout 才會斷開連線，雙方都不會主動發送 &lt;code>Connection:close&lt;/code>；&lt;/p>
&lt;p>多個 client 發送，n 個 client 會建立 n 個到 nginx connection，但是 nginx ← → server 會用同一條 connection 。&lt;/p>
&lt;h3 id="偶發的502-錯誤keep-alive-race-condition">偶發的502 錯誤 — Keep-Alive Race Condition&lt;/h3>
&lt;p>&lt;a class="link" href="https://blog.percy.io/tuning-nginx-behind-google-cloud-platform-http-s-load-balancer-305982ddb340" target="_blank" rel="noopener"
>&lt;strong>Tuning NGINX behind Google Cloud Platform HTTP(S) Load Balancer&lt;/strong>&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="http://theo.im/blog/2017/10/14/suspicious-502-error-from-elb/" target="_blank" rel="noopener"
>** 解决 AWS ELB 偶发的 502 Bad Gateway 错误_ - Timon Wong**&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>The NGINX timeout might be reached &lt;em>at the same time&lt;/em> the load balancer tries to re-use the connection for another HTTP request, which breaks the connection and results in a &lt;strong>502 Bad Gateway&lt;/strong> response from the load balancer.&lt;/p>
&lt;/blockquote>
&lt;p>看到幾篇相關的問題，主要都是發生 race condition，某一方在剛好收到 [FIN, ACK] 後又收到下一個 request，導致了 tcp connection error 回傳 [RST]；&lt;br>
解決方法通常是拉長 api server 端的 keep-alive timeout，讓 load balancer 自己斷開 connection。&lt;/p>
&lt;h4 id="tcp-close-connection">TCP Close Connection&lt;/h4>
&lt;p>&lt;a class="link" href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank" rel="noopener"
>&lt;strong>Transmission Control Protocol - Wikipedia&lt;/strong> &lt;/a>&lt;/p>
&lt;p>當 TCP 決定要關閉連線時，需要四次交握，主要是 client → server 與 server ← client 兩個方向都有一組的 FIN , ACK 交換，才能確保說關閉連線後對方不會再送資料；&lt;/p>
&lt;p>假設目前是 A , B 在通信&lt;/p>
&lt;ol>
&lt;li>A 送出了 [FIN] 表示即將關閉 A → B 的 Connection&lt;/li>
&lt;li>B 回 [ACK]，表示收到，A → B 就關閉了&lt;/li>
&lt;li>但這時候 B → A 還是可以繼續傳送資料，直到 B 送出 [FIN] A 回傳 [ACK]，tcp connection 才真正關閉。&lt;/li>
&lt;/ol>
&lt;p>這個狀態是 &lt;code>half-open&lt;/code> ，某一個方向關閉但另一向還是通的。&lt;/p>
&lt;p>在某些系統(Linux)的實作上僅支援 &lt;code>half-duplex&lt;/code>，當要關閉某一向的 connection 時會連讀取都一併關閉，如果還沒處理完所有的資料，此時 host 會回傳 RST，另一方視此次 request 失敗。&lt;/p>
&lt;h3 id="nginx-優化">Nginx 優化&lt;/h3>
&lt;p>&lt;a class="link" href="https://lanjingling.github.io/2016/06/11/nginx-https-keepalived-youhua/" target="_blank" rel="noopener"
>&lt;strong>nginx优化&amp;ndash;包括https、keepalive等&lt;/strong>&lt;/a>&lt;/p>
&lt;p>keep-alive 有幾個相關的參數，可以依據服務內容而調整，簡單筆記幾個重點&lt;/p>
&lt;ol>
&lt;li>keepalive_requests&lt;br>
一個 persistent connection 最大的服務 request 數量，超過則強迫關閉&lt;/li>
&lt;li>keepalive_timeout&lt;br>
connection idle 超過時間就會被強迫關閉&lt;/li>
&lt;li>keepalive&lt;br>
最大同時 connection idle 數量，如果超過則 idle connection 會被回收&lt;/li>
&lt;/ol>
&lt;h3 id="結語">結語&lt;/h3>
&lt;p>keep-alive 優點在於重複利用 tcp connection，但必須注意&lt;/p>
&lt;ol>
&lt;li>client library 的實踐，確認是否有主動發送 connection: close 機制，否則 server 都會等到 timeout 才斷開連線，會造成太多不必要的 idle。&lt;/li>
&lt;li>nginx ← → server 這段的長連接 timeout 雙方都可以拉長，如果 QPS (query per second) 很高的話，多個 client connection 也會利用同一條 nginx ← → server 的 persistent connection。&lt;/li>
&lt;li>如果有使用 GCP / AWS load balancer 偶發 502錯誤，且 api server 端沒有收到任何連線紀錄，多半是 keep-alive timeout 問題。&lt;/li>
&lt;li>讓 client timeout 大於 server timeout，因為 request 是由 client 發起，就能有效避免 keep-alive race condition。&lt;/li>
&lt;/ol></description></item><item><title>AWS-CDK教學 — Infrastructore As Code 用程式碼管理架構</title><link>https://yuanchieh.page/posts/2019/2019-01-27-aws-cdk%E6%95%99%E5%AD%B8-infrastructore-as-code-%E7%94%A8%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%AE%A1%E7%90%86%E6%9E%B6%E6%A7%8B/</link><pubDate>Sun, 27 Jan 2019 03:29:50 +0000</pubDate><guid>https://yuanchieh.page/posts/2019/2019-01-27-aws-cdk%E6%95%99%E5%AD%B8-infrastructore-as-code-%E7%94%A8%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%AE%A1%E7%90%86%E6%9E%B6%E6%A7%8B/</guid><description>&lt;p>最近陸陸續續在看 AWS re:invent 2018 的影片，主要專注於 CI/CD部分，不得不說看完真的是非常振奮人心啊！&lt;/p>
&lt;p>以往在做架構設計，可能是先畫個架構圖，接著打開網頁登入 AWS Console，看要開幾台 EC2 、VPC 架構、 ALB 設定、CDN 設定、開 S3 Bucket 等等，基本上大多的事情都是透過網頁完成，或是使用 Command Line Tool 完成；&lt;br>
但這樣的缺點是如果公司突然想要重建一份同樣的架構當作 staging 環境，又或是往後需要改動架構，此時必須自己同步文件、修改架構圖等等，在管理上有相當多不方便的地方。&lt;/p>
&lt;h2 id="為什麼不用程式碼來管理">為什麼不用程式碼來管理&lt;/h2>
&lt;p>這也就是這篇要分享的方法，使用 AWS-CDK，AWS-CDK 是一個 nodejs 的 package，安裝後當作 cli tool 使用；&lt;br>
在 AWS-CDK 下提供各個 AWS 既有服務的套件(如 lambda 、 S3 等)，目前提供 C#、Javascript、Typescript、Java，開發時引入這些套件就可以使用了。&lt;/p>
&lt;p>透過程式碼管理，我覺得有幾個好處&lt;/p>
&lt;ol>
&lt;li>更好的封裝與結構&lt;br>
如果是用網頁做設定，基本上行為只能透過文件來溝通，如果是用 shell script 或許也可以做到一部分的自動化，但整體理解上還有蠻多不方便之處，更別說維護的人寫法可能不同，造成維護的困難；&lt;br>
使用 AWS-CDK，他本身是用 OO 的概念封裝既有的 AWS 服務，官方也有提供工具幫助初始專案，也給予一定的程式碼架構建議，後人接手一定會好理解非常多&lt;/li>
&lt;li>版本控制&lt;br>
隨著公司發展，可能會更動架構，透過代碼管理工具可以協助良好管理架構的演進，Rollback 也可以有依據 (例如費用爆掉的時候…)&lt;/li>
&lt;li>跨區域部署&lt;br>
如果你想要跨區域部署同樣的架構，用網頁操作應該會非常頭痛，而且容易出現人工錯誤；&lt;br>
用程式碼就是多一行指定區域， DONE!&lt;/li>
&lt;/ol>
&lt;p>AWS-CDK 底層其實是將程式碼轉成 Cloud Formation，AWS 自定義的服務定義語法，可以理解成 AWS服務的 Assembly Code。&lt;/p>
&lt;blockquote>
&lt;p>＊WARNING：目前發文時間 2019/01/27 還&lt;strong>不建議使用於正式環境&lt;/strong>，但因為他底層是轉成 Cloud Formation，理論上轉換不出錯應該就蠻穩的，目前測試尚未遇到 Bug&lt;/p>
&lt;/blockquote>
&lt;p>在開始 Coding之前，建議使用 AWS-CDK 之前要先熟悉 AWS 服務，例如你想串 Lambda 建議先至少看過文件、用網頁版完整操作過一次，因為有很多參數實際用過才知道怎麼填寫，目前官方網站有良好的文件，但這些文件僅限於參數說明，如果沒實際用過不會知道參數設定後的實質意義與用途；&lt;br>
另外目前我查了一下沒有太多實戰分享，只有一些基本的串接與操作，所以在服務間的串接蠻多是 Try-And-Error 玩出來的，也是我想寫這篇文章的目的，幫助大家上手。&lt;/p>
&lt;p>本篇比較適合已經在使用 AWS 服務一段時間，希望可以用更好方式管理架構的工程師；&lt;br>
後續會使用 Typescript 當作範例，不過概念都是一樣的。&lt;/p>
&lt;p>最後再次提醒，因為還在 pre-release 階段，如果你發現以下程式碼有誤或無法執行，煩請留言。&lt;/p>
&lt;h3 id="安裝-aws-cdk與專案初始化">安裝 AWS-CDK 與專案初始化&lt;/h3>
&lt;p>&lt;a class="link" href="https://cdkworkshop.com/15-prerequisites.html" target="_blank" rel="noopener"
>&lt;strong>cdkworkshop.com&lt;/strong>&lt;/a>&lt;/p>
&lt;p>在開始之前，請確保完成官網的 prerequest 步驟&lt;/p>
&lt;ol>
&lt;li>安裝了 aws-cli&lt;/li>
&lt;li>完成 iam role 設定，實驗性質先開 admin 權限比較方便&lt;/li>
&lt;li>完成 aws configure&lt;/li>
&lt;li>安裝 Nodejs v8.12 以上&lt;/li>
&lt;li>安裝 aws-cdk， &lt;code>npm install -g aws-cdk@0.22.0&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>aws-cdk 主要提供幾個指令&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">// 用於初始化專案，可以指定語言
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ cdk init
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// 查看目前所有的 stack &lt;span class="o">(&lt;/span>後續介紹什麼是 stack&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ cdk ls
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// 查看目前程式碼轉換的 cloud formation
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ cdk synth
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// 查看目前架構的變動
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ cdk diff
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// 部署
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ cdk deploy
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// 初始化環境
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ cdk bootstrap
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>目前我習慣使用 Typescript 開發，搭配 VSCode 有連好的自動提示非常方便。&lt;/p>
&lt;h3 id="實戰部署-scheduled-event-觸發lambda">實戰：部署 Scheduled Event 觸發 Lambda&lt;/h3>
&lt;p>Let’s write some code~ &lt;br>
這次做一個部署到多個區域，定期 2 分鐘去打 &lt;a class="link" href="https://www.president.gov.tw/" target="_blank" rel="noopener"
>https://www.president.gov.tw/&lt;/a> 看台灣總統府頁面在全球的網頁回應速度，接著發訊息到 slack 頻道。&lt;/p>
&lt;p>到專案目錄下，執行 &lt;code>&amp;gt; cdk init app — language=typescript&lt;/code>&lt;/p>
&lt;p>接著同個目錄下，我們需要開兩個 shell，一個 shell 執行 &lt;code>&amp;gt; npm run watch&lt;/code> ，主要是為了自動轉譯 typescript 成 javascript 才可以讓 nodejs 執行；&lt;br>
另一個 shell 用來執行後續的 cmd。&lt;/p>
&lt;p>在目錄下會有常見的 nodejs 專案檔案，有兩個資料夾比較重要 /bin 、 /lib；&lt;/p>
&lt;p>&lt;code>/lib&lt;/code> 主要是放架構定義，初始化之後會有一個 aws-cdk-stack.ts，在 AWS-CDK中， &lt;code>stack&lt;/code> 代表的就是一個架構的 class，例如說目前要設計的架構就是 (scheduled event + lambda)，這就是一個小型的架構；&lt;br>
後續可以讓小架構組合成大架構，就看需求決定如何封裝。&lt;/p>
&lt;p>&lt;code>/bin&lt;/code> 主要是放 &lt;code>app&lt;/code>，也就是最終架構的檔案，主要是整合Stack 初始化與部屬的方式，定義在 aws-cdk.ts 之中。&lt;/p>
&lt;h4 id="aws-cdk-stackts">aws-cdk-stack.ts&lt;/h4>
&lt;p>是不是比想像中的清晰簡單啊，載入對應模組宣告即可，而且 lambda 可以參照本地端的資料夾，自動幫忙打包與部署超方便的；&lt;br>
另外 aws-cdk 文件一個好處是都有把對應的參數文件對照好，所以查起來蠻快的，但是參數量非常大 …..&lt;/p>
&lt;p>Stack 在初始化需要綁定是在哪個 app下，以及獨立的 ID，這後續會再網頁中看到。&lt;/p>
&lt;h4 id="aws-cdkts">aws-cdk.ts&lt;/h4>
&lt;p>基本上就是初始化 Stack 並定義部署的區域，另外的 lambda 與 slack 就看 git repo 參考，不再贅述。&lt;/p>
&lt;p>程式碼完成後，執行以下步驟&lt;/p>
&lt;ol>
&lt;li>檢查&lt;br>
 &lt;code>&amp;gt; cdk list&lt;/code> 查看App下的所有 Stack，接著針對各個 stack 下 &lt;code>&amp;gt; cdk synth AwsCdkStack2&lt;/code> ，大概檢查有沒有 error 與 cloud formation 定義。&lt;/li>
&lt;li>部署&lt;br>
 &lt;code>&amp;gt; cdk deploy&lt;/code> &lt;br>
如果是第一次部署，他可能會跳出需要執行 &lt;code>&amp;gt;cdk bootstrap {專案id/region}&lt;/code> 的錯誤，其他的話就等他慢慢部署；&lt;/li>
&lt;/ol>
&lt;p>cdk 部署時有良好的打印訊息，最棒的是 cdk 會自動處理 aws 服務 iam role 的權限，如果有處理過權限設定就知道這非常的頭痛 XD &lt;br>
因為 AWS 服務切太細了，好處是可設定的非常精準，但缺點就是查找起來很頭痛，通常都要跑個幾次看錯誤log 補權限。&lt;/p>
&lt;p>以下是網頁與 Slack 回應的截圖&lt;/p>
&lt;p>lambda&lt;/p>
&lt;p>&lt;img src="https://yuanchieh.page/post/img/1__mn7RZtoPWTy33Xo9S1TdJg.jpeg"
loading="lazy"
>&lt;/p>
&lt;p>Slack 訊息，看來歐洲回應時間最長，東北亞最快，結果是也不太意外 XD&lt;/p>
&lt;p>&lt;img src="https://yuanchieh.page/post/img/1__JQxsYZQ2OaTEoMSo3tbhMA.jpeg"
loading="lazy"
>&lt;/p>
&lt;p>最後附上完整專案的 github&lt;/p>
&lt;p>&lt;a class="link" href="https://github.com/sj82516/aws-cdk-demo" target="_blank" rel="noopener"
>&lt;strong>sj82516/aws-cdk-demo&lt;/strong>&lt;/a>&lt;/p>
&lt;h2 id="刪除-stack">刪除 Stack&lt;/h2>
&lt;p>假設我想要移除美西的部署，&lt;strong>&lt;em>不要直接從程式碼刪除Stack 重新 deploy&lt;/em>&lt;/strong> ，我實測的結果這樣是不會幫你把東西刪掉的，要改用以下步驟&lt;/p>
&lt;ol>
&lt;li>&lt;code>&amp;gt; cdk destroy AwsCdkStack&lt;/code>&lt;/li>
&lt;li>接著才從程式碼刪除&lt;/li>
&lt;/ol>
&lt;h2 id="結語">結語&lt;/h2>
&lt;p>在雲端服務中，AWS 不得不說是這個行業的領頭羊，而且就技術上個人覺得領先 GCP 不少，基礎服務不好說，但是在跨服務的整合上，AWS 做得非常良好，這或許才是企業用乎所在乎的未來，整套 solution 而不是單個單個服務還要自己慢慢整。&lt;/p>
&lt;p>有了 AWS-CDK 要分享、重用架構就極度方便，之後再來做一系列基於 AWS-CDK 的 AWS 架構研究與分享。&lt;/p></description></item><item><title>[筆記] AWS s3 性能提升小撇步 — Amazon S3 Performance Tips &amp; Tricks</title><link>https://yuanchieh.page/posts/2018/2018-09-25-%E7%AD%86%E8%A8%98-aws-s3-%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E5%B0%8F%E6%92%87%E6%AD%A5-amazon-s3-performance-tips-tricks/</link><pubDate>Tue, 25 Sep 2018 21:34:31 +0000</pubDate><guid>https://yuanchieh.page/posts/2018/2018-09-25-%E7%AD%86%E8%A8%98-aws-s3-%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E5%B0%8F%E6%92%87%E6%AD%A5-amazon-s3-performance-tips-tricks/</guid><description>&lt;p>&lt;a class="link" href="https://aws.amazon.com/tw/blogs/aws/amazon-s3-performance-tips-tricks-seattle-hiring-event/" target="_blank" rel="noopener"
>&lt;strong>Amazon S3 Performance Tips &amp;amp; Tricks + Seattle S3 Hiring Event | Amazon Web Services&lt;/strong>&lt;/a>&lt;/p>
&lt;p>AWS S3 用來做靜態資源管理，可以用來儲存非常大量的資料且有很高保持性(duribility:99.9999999%)的保證；&lt;br>
在這篇官方的部落格中記載著S3內部的一些儲存機制以及優化的小技巧。&lt;/p>
&lt;p>如果是每秒 API Request小於 50者，其實不太會有影響，S3 有自動的監控程序(Agent)，試著去平衡資源與增加系統的平均附載。&lt;/p>
&lt;p>S3在內部維護了一張 Map，Map對應的Key 是 Bucket 中物件的名稱，S3會用物件的初始名稱當作 Key；&lt;br>
實際物件的儲存會被分散到不同的 parition中，而 S3為了提供依照按字典順序排列的API， 在做 partitioning 的依據同樣是透過 Bucket的物件初始名稱；&lt;/p>
&lt;p>所以如何取 &lt;code>Bucket的物件名稱&lt;/code>就是影響性能的關鍵，在S3內部 Map的key&lt;br>
&lt;code>bucketname/keyname&lt;/code> ，S3會自動取前綴&lt;/p>
&lt;p>有些人會習慣用 user ID / game ID/ 日期 / 遞增數字等，這些 Key的共通特性是前綴類似，這當作S3 Key會導致幾個問題&lt;br>
1. 傾向儲存在同一個 partition中&lt;br>
2. 所有的 partition 會有漸冷的效果，例如用日期儲存，通常越近的日期資料越容易存取，也就是partition 的使用量不平均&lt;/p>
&lt;p>以下就是不好的示範&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="line">&lt;span class="cl">2134857/gamedata/start.png
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2134857/gamedata/resource.rsrc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2134857/gamedata/results.txt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2134858/gamedata/start.png
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2134858/gamedata/resource.rsrc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2134858/gamedata/results.txt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2134859/gamedata/start.png
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2134859/gamedata/resource.rsrc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2134859/gamedata/results.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>有個非常簡單的方法可以做到，也就是在開頭加 hash，或是將日期字串反轉，總之要確保前兩到三位是不重複字串且寫入的物件數雷同&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-md" data-lang="md">&lt;span class="line">&lt;span class="cl">7584312/gamedata/start.png
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7584312/gamedata/resource.rsrc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">7584312/gamedata/results.txt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8584312/gamedata/start.png
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8584312/gamedata/resource.rsrc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">8584312/gamedata/results.txt
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">9584312/gamedata/start.png
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">9584312/gamedata/resource.rsrc
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">9584312/gamedata/results.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>S3會自動識別 prefix並分散到不同的 partition&lt;/p>
&lt;p>/7&lt;br>
/8&lt;br>
/9&lt;/p>
&lt;p>至於 prefix 真正到底如何取值文章並沒有說明，僅提到 prefix 理論上只有兩到三位即可，根據另一篇 AWS官方文章 &lt;a class="link" href="https://docs.aws.amazon.com/AmazonS3/latest/dev/request-rate-perf-considerations.html" target="_blank" rel="noopener"
>Request Rate and Performance Guidelines&lt;/a>，應用程式存取S3的API限制為&lt;/p>
&lt;blockquote>
&lt;p>3,500 PUT/POST/DELETE and 5,500 GET requests per second per &lt;code>prefix&lt;/code> in a bucket&lt;/p>
&lt;/blockquote>
&lt;p>所以 hex hash 三位，最大讀取值可達 16 * 16 * 16 * 5500 GET API Call /per second，這理論上可以滿足絕大多數的產品需求了；&lt;br>
甚至大多數的產品還不需要 prefix的命名優化。&lt;/p></description></item></channel></rss>