<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="每次在思考程式語言的執行、I/O 的同步與非同總會有些觀念繞不過去，這次從硬體到作業系統重新理解，對於I/O 的執行有不同的認識"><meta name=keywords content="I/O,同步,非同步"><title>I/O 同步與非同步：從硬體、作業系統到應用程式</title><link rel=canonical href=https://yuanchieh.page/posts/2022/2022-02-06-i/o-%E5%90%8C%E6%AD%A5%E8%88%87%E9%9D%9E%E5%90%8C%E6%AD%A5%E5%BE%9E%E7%A1%AC%E9%AB%94%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E5%88%B0%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F/><link rel=stylesheet href=/scss/style.min.ff300df33b80e2ac49809c825614392ed1c7b27591d65d3c4043602cd162e25f.css><meta property="og:title" content="I/O 同步與非同步：從硬體、作業系統到應用程式"><meta property="og:description" content="每次在思考程式語言的執行、I/O 的同步與非同總會有些觀念繞不過去，這次從硬體到作業系統重新理解，對於I/O 的執行有不同的認識"><meta property="og:url" content="https://yuanchieh.page/posts/2022/2022-02-06-i/o-%E5%90%8C%E6%AD%A5%E8%88%87%E9%9D%9E%E5%90%8C%E6%AD%A5%E5%BE%9E%E7%A1%AC%E9%AB%94%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E5%88%B0%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F/"><meta property="og:site_name" content="Yuanchieh"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:published_time" content="2022-02-06T01:21:40+00:00"><meta property="article:modified_time" content="2022-02-06T01:21:40+00:00"><meta name=twitter:title content="I/O 同步與非同步：從硬體、作業系統到應用程式"><meta name=twitter:description content="每次在思考程式語言的執行、I/O 的同步與非同總會有些觀念繞不過去，這次從硬體到作業系統重新理解，對於I/O 的執行有不同的認識"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-82837682-4","auto"),ga("send","pageview"))</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-82837682-4"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-82837682-4")</script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src="https://avatars0.githubusercontent.com/u/6858460?s=460&amp;v=4" width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Yuanchieh</a></h1><h2 class=site-description>生命是長期而持續的累積</h2></div></header><ol class=social-menu><li><a href=https://github.com/sj82516 target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><div class=menu-bottom-section><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#作業系統與-io-裝置>作業系統與 I/O 裝置</a></li><li><a href=#linux-kernel-module-實作>Linux Kernel module 實作</a><ol><li><a href=#kernel-spaceuser-space-與-kernel-module>kernel space、user space 與 kernel module</a></li><li><a href=#hello-world---kernel-module>hello world - kernel module</a><ol><li><a href=#1-hello-world>1. hello world</a></li><li><a href=#2-條列--安裝--移除-kernel-module>2. 條列 / 安裝 / 移除 kernel module</a></li></ol></li><li><a href=#device-driver>device driver</a><ol><li><a href=#1-註冊裝置>1. 註冊裝置</a></li><li><a href=#2-註冊檔案操作>2. 註冊檔案操作</a></li><li><a href=#3-範例程式碼>3. 範例程式碼</a></li><li><a href=#io-blocking--non-blocking>IO blocking / non-blocking</a></li></ol></li><li><a href=#system-call>system call</a><ol><li><a href=#1-從-printf-觀察-system-call>1. 從 printf 觀察 system call</a></li><li><a href=#2-修改-system-call>2. 修改 system call</a></li></ol></li></ol></li><li><a href=#cpu-與-hardware-interrupt>CPU 與 Hardware interrupt</a></li><li><a href=#延伸linux-的-asynchronous-io>延伸：Linux 的 Asynchronous I/O</a></li><li><a href=#總結>總結</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/linux/>Linux</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/posts/2022/2022-02-06-i/o-%E5%90%8C%E6%AD%A5%E8%88%87%E9%9D%9E%E5%90%8C%E6%AD%A5%E5%BE%9E%E7%A1%AC%E9%AB%94%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E5%88%B0%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F/>I/O 同步與非同步：從硬體、作業系統到應用程式</a></h2><h3 class=article-subtitle>每次在思考程式語言的執行、I/O 的同步與非同總會有些觀念繞不過去，這次從硬體到作業系統重新理解，對於I/O 的執行有不同的認識</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Feb 06, 2022</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>9 minute read</time></div></footer></div></header><section class=article-content><p>從應用程式的角度，執行任務可以分成 I/O bound 與 CPU bound，而 I/O 處理相比於 CPU 運算速度慢好幾個層級，所以當 I/O 還沒準備好時會「主動讓」給其他任務，盡可能地讓 CPU 保持忙碌，等到 「I/O 準備好再重新回到 CPU 執行」</p><p>在之前理解 Nodejs non-blocking I/O 時，官方文件 <a class=link href=https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/ target=_blank rel=noopener>Overview of Blocking vs Non-Blocking</a> 寫到</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Any code that is expected to run in a concurrent manner must allow the event loop to <span class=k>continue</span> running as non-JavaScript operations, like I/O, are occurring.
</span></span></code></pre></td></tr></table></div></div><p>Nodejs sdk 有提供 non-blocking I/O 機制，底層 libuv 會處理 event loop 與其餘 I/O 的執行，「當 I/O 執行時可以讓其他的 JavaScript code 繼續運行不被 block」</p><p>所有用「」括起來的地方都是我所想不透的，為什麼 I/O 運行時其他 JavaScript Code 可以繼續運行？是因為 Nodejs 有某種特殊的方法知道目前的程式在等待 I/O 所以主動切換不同的任務執行？如果不是 Nodejs runtime 切換，那會是作業系統切換的嗎？該怎麼切換？<br>又為什麼 I/O 的處理不需要 CPU 的介入嗎？ CPU 怎麼知道 IO 處理完了該繼續往下執行？是不是我的 IO 全部改成 asynchronous 效能就突飛猛進？那為什麼 async io 並不是每個程式語言執行時的預設支援？</p><p>同樣最近在看 Golang goroutine <a class=link href=https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a target=_blank rel=noopener>Go: Goroutine, OS Thread and CPU Management</a>時又遇到相同的問題，當讀到 goroutine 等待 I/O 回應時 M 會解除 P 並進入等待，讓其他的 M 執行；如果是遇到 network 相關的 I/O 則推至 network poll 等待 network 完成</p><p>從應用程式開發者的角度，我們只要知道有<code>神秘的小精靈</code>會幫我們完成 I/O，JavaScript callback / goroutine system call 可以在非同步的狀況下拿到 I/O 回傳的結果就好</p><blockquote><p>但往下思索，這一切的黑幕背後有滿山滿谷的疑惑</p></blockquote><h2 id=作業系統與-io-裝置>作業系統與 I/O 裝置</h2><p>為了讓開發者可以專注於軟體開發，應用程式多半運行在作業系統之上，透過作業系統提供的統一介面抽象化硬體，並確保單一應用程式不會霸佔硬體資源，所有與 I/O 裝置設備通訊都必須經過作業系統的操控 system call，而這神秘的小精靈就躲在這個環節中</p><p>從 high level 的角度來看，大致如下
<img src=/post/2022/img/0206/io.png loading=lazy>
分成兩條路線：應用程式主動呼叫與 I/O 裝置主動觸發</p><ol><li>應用程式呼叫 system call，此時送出 interrupt 切換到 kernel space 執行</li><li>system call 操作(如讀寫) I/O 裝置對應的 File，觸發 kernel module 運作，這邊專指 device driver 的部分</li><li>當 I/O 裝置完成特定動作，如網卡接收到封包 / 硬碟讀取完資料，會直接透過<code>硬體打出 interrupt 訊號給 CPU</code></li><li>CPU 會找到 OS 註冊對應的 <code>interrupt handler 處理</code>，類似於 API server 註冊 api route 等 request 近來就到對應的 handler，mapping 過程稱為 <code>ISR</code></li><li>ISR 會找到對應的 device driver 處理</li><li>補充：這邊我們只探討跟 I/O 相關的議題，所以 interrupt handler 指的是就是以 kernel module 存在的 I/O device driver，其他還有如 timer interrupt handler 等</li></ol><p>所以真正有趣的地方在於</p><blockquote><p>I/O device driver 如何在準備資料的時候釋放 CPU 資源，並在資料準備完成後透過 interrupt 重新向 OS 排程並回傳資料</p></blockquote><p>以下將以 Linux 為主，探索作業系統與 I/O 裝置的互動</p><h2 id=linux-kernel-module-實作>Linux Kernel module 實作</h2><p>參考內容 <a class=link href=https://sysprog21.github.io/lkmpg/#introduction target=_blank rel=noopener>The Linux Kernel Module Programming Guide</a>，現在學習 Linux 真的很幸運有 Jserv 大大的貢獻，用影片與共筆分享在成大教授的課程，並維護這份易讀好懂的 Linux Kernel 開發教學，以下將先以實作切入</p><h3 id=kernel-spaceuser-space-與-kernel-module>kernel space、user space 與 kernel module</h3><p>先前提到作業系統是為了統一管理硬體而存在，避免應用程式霸佔資源而使其他應用程式無法使用，在執行層面 Linux 拆成 kernel space 與 user space，kernel space 可以操作所以的資源，而一般應用程式執行於 user space 當中，這樣的保護是基於 <code>CPU 所提供</code>，CPU 有不同的模式可以用型，kernel space 有最高權限 (supervisor mode) 而 user space 則是最低權限 (protect mode)</p><p>kernel module 是在 <code>Linux runtime 可以動態開關而不需要重新編譯 kernel image 的一段程式</code>，可直接在 kernel space 執行，常見為 I/O device driver</p><p>又因為 kernel module 是屬於 kernel 的一部分，所以他們的資源是共享的如記憶體，同樣的如果 <code>kernel module 有問題連帶整個 kernel 都會 crash</code>，以下實驗建議另外開 VM 嘗試，我自己是用 Macbook M1 + Ubuntu 20.20 VM 執行</p><h3 id=hello-world---kernel-module>hello world - kernel module</h3><p>參考資料 <a class=link href=https://sysprog21.github.io/lkmpg/#hello-and-goodbye target=_blank rel=noopener>lkmpg - 4.2 Hello and Goodbye</a><br>讓我們先從最簡單的 hello world 開始，先了解最基本的 kernel module 安裝、卸載與執行過程</p><h4 id=1-hello-world>1. hello world</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* 
</span></span></span><span class=line><span class=cl><span class=cm> * hello-1.c - The simplest kernel module. 
</span></span></span><span class=line><span class=cl><span class=cm> */</span> 
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/kernel.h&gt; /* Needed for pr_info() */ </span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;linux/module.h&gt; /* Needed by all modules */ </span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span> 
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>init_module</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=nf>pr_info</span><span class=p>(</span><span class=s>&#34;Hello world 1.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    <span class=cm>/* A non 0 return means init_module failed; module can&#39;t be loaded. */</span> 
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>cleanup_module</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=nf>pr_info</span><span class=p>(</span><span class=s>&#34;Goodbye world 1.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span> 
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=nf>MODULE_LICENSE</span><span class=p>(</span><span class=s>&#34;GPL&#34;</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>編寫 kernel module 時，有以下三點必備</p><ol><li>當 module 安裝時要做什麼：init_module</li><li>當 module 移除時要做什麼：cleanup_module</li><li>指定 module 的 license：MODULE_LICENSE</li></ol><p>需要注意的是，這個 program 在輸出時是用 pr_info 而非 printf，原因是參考 <a class=link href=https://www.calleluks.com/the-four-stages-of-compiling-a-c-program/ target=_blank rel=noopener>C 編譯過程</a> 在第三階段 Assembly 產出 object code，如果有外部函式庫呼叫會在第四 Linking 階段補上缺少的 object code；<br>但是 kernel module 的第四階段不同，他只能解析 kernel 所註冊的 symbol，也就是 kernel 本身提供的 system call，可以在 <code>/proc/kallsyms</code> 查看</p><h4 id=2-條列--安裝--移除-kernel-module>2. 條列 / 安裝 / 移除 kernel module</h4><p>編譯用的 MakeFile 參考上附連結，產出 module object code 後，可以透過以下指令操作 kernel module</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>// 條列
</span></span><span class=line><span class=cl>$ sudo lsmod
</span></span><span class=line><span class=cl>// 安裝
</span></span><span class=line><span class=cl>$ sudo insmod <span class=o>{</span>module.ko<span class=o>}</span>
</span></span><span class=line><span class=cl>// 移除
</span></span><span class=line><span class=cl>$ sudo rmmode <span class=o>{</span>module<span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>可以透過 <code>$ sudo journalctl --since "1 hour ago" | grep kernel</code> 查看近一小時 kernel module 打印結果</p><h3 id=device-driver>device driver</h3><p><code>所有的裝置在 linux 中都是 file</code>，資料結構可以參考 <a class=link href=https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fs.h target=_blank rel=noopener>include/linux/fs.h</a>，首先要先釐清這邊的 File <code>只存在於 kernel</code>，雖然中文可能都被翻成文件或檔案，但實際上與檔案系統中的檔案概念是不同的! 後者通常是叫做 <strong>inode</strong></p><p>所以每一個裝置在 linux 中都是以一個 file 存在，通常儲存於 <code>/dev/</code> 底下，而 device driver 則是 user space 應用程式與 device 溝通的管道，流程大致是</p><ol><li>driver 向 kernel 註冊取得屬於自己的裝置編號與指定檔案</li><li>driver 定義檔案操作</li></ol><h4 id=1-註冊裝置>1. 註冊裝置</h4><p>參考資料 <a class=link href=https://sysprog21.github.io/lkmpg/#device-drivers target=_blank rel=noopener>lkmpg - 5.6 Device Drivers</a>
先觀察系統中既有的裝置</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ls -l /dev/
</span></span></code></pre></td></tr></table></div></div><p>可以看到類似的輸出</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>brw-rw----  <span class=m>1</span> root  disk  3, <span class=m>1</span> Jul  <span class=m>5</span>  <span class=m>2000</span> /dev/hda1
</span></span><span class=line><span class=cl>brw-rw----  <span class=m>1</span> root  disk  3, <span class=m>2</span> Jul  <span class=m>5</span>  <span class=m>2000</span> /dev/hda2
</span></span><span class=line><span class=cl>brw-rw----  <span class=m>1</span> root  disk  3, <span class=m>3</span> Jul  <span class=m>5</span>  <span class=m>2000</span> /dev/hda3
</span></span></code></pre></td></tr></table></div></div><p>注意到 &ldquo;3, 1&rdquo; 這類型的字串，前面是 major number 後面是 minor number，分別代表 <code>指定 driver, 裝置 id</code>，每個 device driver 都會被分配一個 id，而可能有多個裝置都是由同一個 driver 所驅動，所以有第二個 minor id 讓 driver 區分不同的硬體</p><p>接著注意到最前的字元，可能會看到 <code>d / b / c</code> 三種，d 代表 directory 目錄，b 代表 block、c 代表 char；<br>block device 是指說操作會以 block 為單位，所以有時操作會被 buffer 後才執行，例如硬碟儲存裝置，可以最佳化讀寫的效率；<br>char device 則沒有 buffer，可以任意讀寫不同的大小，幾乎大多數的裝置都是 char device</p><h4 id=2-註冊檔案操作>2. 註冊檔案操作</h4><p>當我們想指定 device driver 如何操作檔案時，會定義 file_operations，指定當檔案被讀取 / 寫入時要對應觸發的 handler function，可以看到以下 struct 中幾乎都是定義 <a class=link href=https://chenhh.gitbooks.io/parallel_processing/content/cython/function_pointer.html target=_blank rel=noopener>function pointer</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>file_operations</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>module</span> <span class=o>*</span><span class=n>owner</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=kt>loff_t</span> <span class=p>(</span><span class=o>*</span><span class=n>llseek</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=p>,</span> <span class=kt>loff_t</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=kt>ssize_t</span> <span class=p>(</span><span class=o>*</span><span class=n>read</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=p>,</span> <span class=kt>char</span> <span class=n>__user</span> <span class=o>*</span><span class=p>,</span> <span class=kt>size_t</span><span class=p>,</span> <span class=kt>loff_t</span> <span class=o>*</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=kt>ssize_t</span> <span class=p>(</span><span class=o>*</span><span class=n>write</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=n>__user</span> <span class=o>*</span><span class=p>,</span> <span class=kt>size_t</span><span class=p>,</span> <span class=kt>loff_t</span> <span class=o>*</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=kt>ssize_t</span> <span class=p>(</span><span class=o>*</span><span class=n>read_iter</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>kiocb</span> <span class=o>*</span><span class=p>,</span> <span class=k>struct</span> <span class=n>iov_iter</span> <span class=o>*</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=kt>ssize_t</span> <span class=p>(</span><span class=o>*</span><span class=n>write_iter</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>kiocb</span> <span class=o>*</span><span class=p>,</span> <span class=k>struct</span> <span class=n>iov_iter</span> <span class=o>*</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=p>.....</span>
</span></span></code></pre></td></tr></table></div></div><p>補充 file 相關資料 <a class=link href=https://blog.jaycetyle.com/2018/12/linux-fd-open-close/ target=_blank rel=noopener>Linux 系統程式設計 - fd 及 open()、close() 系統呼叫</a>，file 在 Linux 中必須先被 open() 才能執行後續的讀寫操作，open() 時會把檔案稱作 <code>open file</code>，此時會回傳 <code>file descriptor</code>，資料結構就是上面的 file_operations 紀錄每種動作對應的處理方法</p><h4 id=3-範例程式碼>3. 範例程式碼</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span><span class=lnt>87
</span><span class=lnt>88
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=n>file_operations</span> <span class=n>chardev_fops</span> <span class=o>=</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>read</span> <span class=o>=</span> <span class=n>device_read</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>write</span> <span class=o>=</span> <span class=n>device_write</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>open</span> <span class=o>=</span> <span class=n>device_open</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>release</span> <span class=o>=</span> <span class=n>device_release</span><span class=p>,</span> 
</span></span><span class=line><span class=cl><span class=p>};</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>__init</span> <span class=nf>chardev_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=n>major</span> <span class=o>=</span> <span class=nf>register_chrdev</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>DEVICE_NAME</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>chardev_fops</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>major</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>        <span class=nf>pr_alert</span><span class=p>(</span><span class=s>&#34;Registering char device failed with %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>major</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>major</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>pr_info</span><span class=p>(</span><span class=s>&#34;I was assigned major number %d.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>major</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=n>cls</span> <span class=o>=</span> <span class=nf>class_create</span><span class=p>(</span><span class=n>THIS_MODULE</span><span class=p>,</span> <span class=n>DEVICE_NAME</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=nf>device_create</span><span class=p>(</span><span class=n>cls</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nf>MKDEV</span><span class=p>(</span><span class=n>major</span><span class=p>,</span> <span class=mi>0</span><span class=p>),</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>DEVICE_NAME</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>pr_info</span><span class=p>(</span><span class=s>&#34;Device created on /dev/%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>DEVICE_NAME</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>SUCCESS</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Methods */</span> 
</span></span><span class=line><span class=cl><span class=cm>/* Called when a process tries to open the device file, like 
</span></span></span><span class=line><span class=cl><span class=cm> * &#34;sudo cat /dev/chardev&#34; 
</span></span></span><span class=line><span class=cl><span class=cm> */</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>device_open</span><span class=p>(</span><span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=n>inode</span><span class=p>,</span> <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>file</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>counter</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>atomic_cmpxchg</span><span class=p>(</span><span class=o>&amp;</span><span class=n>already_open</span><span class=p>,</span> <span class=n>CDEV_NOT_USED</span><span class=p>,</span> <span class=n>CDEV_EXCLUSIVE_OPEN</span><span class=p>))</span> 
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=n>EBUSY</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>sprintf</span><span class=p>(</span><span class=n>msg</span><span class=p>,</span> <span class=s>&#34;I already told you %d times Hello world!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>counter</span><span class=o>++</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=nf>try_module_get</span><span class=p>(</span><span class=n>THIS_MODULE</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>SUCCESS</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* This function is called whenever a process which has already opened the 
</span></span></span><span class=line><span class=cl><span class=cm> * device file attempts to read from it. 
</span></span></span><span class=line><span class=cl><span class=cm> */</span> 
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>ssize_t</span> <span class=nf>device_read</span><span class=p>(</span><span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>file</span><span class=p>,</span> <span class=cm>/* see include/linux/fs.h   */</span> 
</span></span><span class=line><span class=cl>                           <span class=kt>char</span> <span class=n>__user</span> <span class=o>*</span><span class=n>buffer</span><span class=p>,</span> <span class=cm>/* buffer to be filled  */</span> 
</span></span><span class=line><span class=cl>                           <span class=kt>size_t</span> <span class=n>length</span><span class=p>,</span> <span class=cm>/* length of the buffer     */</span>
</span></span><span class=line><span class=cl>                           <span class=kt>loff_t</span> <span class=o>*</span><span class=n>offset</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Number of bytes actually written to the buffer */</span> 
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>bytes_read</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=cm>/* How far did the process reading the message get? Useful if the message 
</span></span></span><span class=line><span class=cl><span class=cm>     * is larger than the size of the buffer we get to fill in device_read. 
</span></span></span><span class=line><span class=cl><span class=cm>     */</span> 
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>message_ptr</span> <span class=o>=</span> <span class=n>message</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!*</span><span class=p>(</span><span class=n>message_ptr</span> <span class=o>+</span> <span class=o>*</span><span class=n>offset</span><span class=p>))</span> <span class=p>{</span> <span class=cm>/* we are at the end of message */</span> 
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>offset</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=cm>/* reset the offset */</span> 
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span> <span class=cm>/* signify end of file */</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>message_ptr</span> <span class=o>+=</span> <span class=o>*</span><span class=n>offset</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Actually put the data into the buffer */</span> 
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>length</span> <span class=o>&amp;&amp;</span> <span class=o>*</span><span class=n>message_ptr</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>        <span class=cm>/* Because the buffer is in the user data segment, not the kernel 
</span></span></span><span class=line><span class=cl><span class=cm>         * data segment, assignment would not work. Instead, we have to 
</span></span></span><span class=line><span class=cl><span class=cm>         * use put_user which copies data from the kernel data segment to 
</span></span></span><span class=line><span class=cl><span class=cm>         * the user data segment. 
</span></span></span><span class=line><span class=cl><span class=cm>         */</span> 
</span></span><span class=line><span class=cl>        <span class=nf>put_user</span><span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=n>message_ptr</span><span class=o>++</span><span class=p>),</span> <span class=n>buffer</span><span class=o>++</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>        <span class=n>length</span><span class=o>--</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>        <span class=n>bytes_read</span><span class=o>++</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>pr_info</span><span class=p>(</span><span class=s>&#34;Read %d bytes, %ld left</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>bytes_read</span><span class=p>,</span> <span class=n>length</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>offset</span> <span class=o>+=</span> <span class=n>bytes_read</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Read functions are supposed to return the number of bytes actually 
</span></span></span><span class=line><span class=cl><span class=cm>     * inserted into the buffer. 
</span></span></span><span class=line><span class=cl><span class=cm>     */</span> 
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>bytes_read</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span></code></pre></td></tr></table></div></div><p>結論關鍵的程式碼</p><ol><li>透過 register_chrdev 註冊裝置與指定的 file，系統會返回 major number</li><li>註冊 file_operators，可以挑選需要的 handler 註冊</li><li>可以注意一下 device_read 註解，裡面有個 system call <code>put_user</code>，因為 driver 是在 kernel mode，而 read 是從 user space 觸發，當今天 driver 想要回傳資料給 user space，不能直接寫入記憶體，而是需要透過 put_user 將記憶體從 kernel space 複製到 user space</li></ol><p>執行上的細節就不贅述，有興趣可以看參考資料</p><h4 id=io-blocking--non-blocking>IO blocking / non-blocking</h4><p>參考資料 <a class=link href=https://sysprog21.github.io/lkmpg/#blocking-processes-and-threads target=_blank rel=noopener>lkmpg - 11 Blocking Processes and threads</a></p><p>當應用程式決定操作 I/O 時，device driver 可能面臨資料尚未準備好的情況，此時會透過 <code>O_NONBLOCK</code> flag 決定是否為 block 應用程式，如果 non-blocking 則直接回傳錯誤 <code>-O_NONBLOCK</code> 讓應用程式晚點重試 (polling)，這也就是 Nodejs 所透過的方式，non-blocking I/O (這句話不全然對，還是要看 libuv 針對不同 I/O 的實作，但 non-blocking 就是指這種情況沒錯)</p><p>或是應用程式選擇 block mode，此時 device driver 還在等待資料的同時，可以選擇透過 <code>wait_event_interruptible</code> 主動交出 CPU 控制權，避免無謂的佔用 CPU 資源；
同時在 wait 之前會先註冊對應的 <code>wake_up</code> 事件，或是收到 signal 會再叫醒原本沈睡的 process</p><p><img src=/post/2022/img/0206/blocking.png loading=lazy><br>*圖片參考資料 <a class=link href=https://medium.com/@clu1022/%E6%B7%BA%E8%AB%87i-o-model-32da09c619e6 target=_blank rel=noopener>https://medium.com/@clu1022/%E6%B7%BA%E8%AB%87i-o-model-32da09c619e6</a></p><p>重新回來看 blocking 與 non-blocking 的圖，這邊是從應用程式角度出發，blocking I/O 會在 kernel device driver 沒有資料時等待，但從 kernel 角度，如果有指定 interruptable 則作業系統會切換到不同的 process 去，所以也不會有資源浪費的問題 (撇除 context switching 開銷)</p><h3 id=system-call>system call</h3><p>參考資料 <a class=link href=https://sysprog21.github.io/lkmpg/#system-calls target=_blank rel=noopener>lkmpg - 10. system call</a></p><p>前面實作了簡單的 kernel module，並看到 device driver 可以在 file 發生變化時產生對應的行為，但一般來說應用程式與 kernel 的互動是透過封裝過後的 system call</p><p>Linux kernel 會有一張 table <code>sys_call_table</code> 儲存支援的 system call 與對應的 address， 當應用程式需要操作硬體需要指定 system call，例如 open() 開啟檔案 / read() 讀取檔案等，在暫存器寫入指定資料後透過特殊指令 interrupt 通知 CPU 要切換 kernel space 執行 (在 intel 中是 0x80)，進階資料可以參考 <a class=link href=https://en.wikipedia.org/wiki/Protection_ring target=_blank rel=noopener>CPU protection ring</a></p><h4 id=1-從-printf-觀察-system-call>1. 從 printf 觀察 system call</h4><p>參考 <a class=link href=https://sysprog21.github.io/lkmpg/#functions-available-to-modules target=_blank rel=noopener>lkmpg 5.2 Functions available to modules</a>
透過最簡單的 c program printf 來看 system call 的執行</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt; </span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span> 
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>打包後透過 <a class=link href=https://strace.io/ target=_blank rel=noopener>strace</a> 查看 system call 狀況</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ gcc -Wall -o hello hello.c
</span></span><span class=line><span class=cl>$ strace ./hello.o
</span></span></code></pre></td></tr></table></div></div><p>打印出蠻多東西，包含一些 memory allocate 的指令等，最終可以看到 <code>write</code> 的 system call 呼叫</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>write<span class=o>(</span>1, <span class=s2>&#34;hello world&#34;</span>, 11hello world<span class=o>)</span>
</span></span><span class=line><span class=cl>exit_group<span class=o>(</span>0<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=2-修改-system-call>2. 修改 system call</h4><p>如果我們希望修改 system call，理論上可以直接改 sys_call_table 的 mapping，但基於安全性考量這是無法直接在 runtime 操作的，原因是避免 hacker 直接修改 system call</p><p>第二個嘗試可以透過 <code>$sudo grep sys_call_table /proc/kallsyms</code> 找出 sys_call_table 所儲存的實際記憶體位置並替換，但這目前也不行，同樣是因為安全性考量， Linux kernel 在每次 boot 時會動態擾亂 kernel code 跟 data (稱為 KASLR)，增加 hacker 嘗試攻擊的難度</p><p>一個可行的做法是透過 <a class=link href=https://ztex.medium.com/kprobe-%E7%AD%86%E8%A8%98-59d4bdb1e1fe target=_blank rel=noopener>kprobe</a>，這是一個 kernel debug 的工具，當 CPU 執行到中斷點時會保存暫存器狀態，並執行 kprobe 指定的指令，可以透過這種方式去動態調整 system call 執行</p><p>但上面的方法在 production 很危險，試想如果有多個 kernel module 去調整 system call，在 restore 時可能會發生意外，不論是復原錯誤或是執行到已經移除的 kernel module，所以建議是直接重新編譯 kernel</p><h2 id=cpu-與-hardware-interrupt>CPU 與 Hardware interrupt</h2><p>上面大致描述綠線的走向，從 user space 呼叫 system call，觸發對應 device driver 所指定的 file operation</p><p>接下來看藍線的部分，當 I/O device 收到外部訊號如網卡收到封包、鍵盤被按下按鈕，如何送出中斷給 CPU 並進入後續的處理</p><p>具體內容請參考宅色夫的 <a class=link href=https://hackmd.io/@sysprog/linux-interrupt target=_blank rel=noopener>Linux 核心設計: 中斷處理和現代架構考量</a>，這邊僅大致提一下流程</p><ol><li>I/O 裝置送出 Interrupt Request (IRQ)</li><li>Hardware controller 整理後送出 interrupt vector 到 CPU</li><li>CPU 切換模式立即處理 interrupt，透過 ISR 找到對應的 Interrupt Handler</li><li>Interrupt handler 中有分成 top half / bottom half，top half 是不會被其他 Interrupt 中斷，所以一定會當下完成；而 bottom half 則會被排入 softiqr 重新排成，<code>soft</code> 在 OS 中有時是代表不確定何時會被完成</li></ol><p>實作面的部分參考 <a class=link href=https://sysprog21.github.io/lkmpg/#detecting-button-presses target=_blank rel=noopener>lkmpg 15.2 Detecting button presses</a>，透過 <code>request_irq</code> 註冊 interrupt request，當指定的 I/O 發生 interrupt 時就會呼叫註冊的 funtion</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>ret</span> <span class=o>=</span> <span class=nf>request_irq</span><span class=p>(</span><span class=n>button_irqs</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>button_isr</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                    <span class=n>IRQF_TRIGGER_RISING</span> <span class=o>|</span> <span class=n>IRQF_TRIGGER_FALLING</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                    <span class=s>&#34;gpiomod#button1&#34;</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span> 
</span></span></code></pre></td></tr></table></div></div><p>更多的討論可以參考文件，不同的 CPU 與作業系統有不同的考量，考慮到排程 realtime OS 的設計又會有不同</p><h2 id=延伸linux-的-asynchronous-io>延伸：Linux 的 Asynchronous I/O</h2><p>現在流行的 network I/O 處理方式是透過 I/O multiplexing，如 Linux 的 epoll，而 asynchrous I/O 看起來十分的迷人，應用程式發出請求後就直接等到作業系統通知，中間完全不用等待，但為什麼目前沒有被大規模採納呢？</p><p><img src=/post/2022/img/0206/io2.png loading=lazy><br>*圖片參考資料 <a class=link href=https://medium.com/@clu1022/%E6%B7%BA%E8%AB%87i-o-model-32da09c619e6 target=_blank rel=noopener>https://medium.com/@clu1022/%E6%B7%BA%E8%AB%87i-o-model-32da09c619e6</a></p><p>參考資料 <a class=link href=https://kernel.dk/io_uring.pdf target=_blank rel=noopener>Efficient IO with io_uring</a>，AIO 在 Linux 2.5 就已經加入了，但持續被詬病例如針對 buffer i/o 還是會變成 synchronous 且 API 難以使用，在 Linux 5.1 後加入了 <code>io_urning</code>新的 AIO API 並持續優化</p><p>libuv 有開始討論導入 io_uring 的部分，有人提供 <a class=link href=https://github.com/libuv/libuv/issues/1947#issuecomment-485230126 target=_blank rel=noopener>benchmark</a> 在讀取檔案部分可以比原本的 thread pool 設計更快</p><p><a class=link href=https://stackoverflow.com/questions/13407542/is-there-really-no-asynchronous-block-i-o-on-linux target=_blank rel=noopener>SO: Is there really no asynchronous block I/O on Linux?</a> 裡面有提供很多的相關連結，資料庫如 PostgreSQL / RocksDB 嘗試用 io_uring 提升硬碟讀寫效能，在 networking 方面也有一些嘗試，在另一篇文章 <a class=link href=https://hackmd.io/@shanvia/B1Ds1vlAD target=_blank rel=noopener>Epoll vs. io_uring 效能測試與比較</a>看起來效能提升不少，CPU 使用率低且能處理更多的 request，之後有機會再深入研究</p><h2 id=總結>總結</h2><p>突然間不知如何總結，研究的過程比想像中發散，看了很多文件 XD</p><p>大抵上從 high level 角度理解了整個 I/O 發生的過程，認識到了「應用程式讀寫 IO 的過程」，中間涉及到 system call / kernel module 的執行，以及 OS context switch 的過程，或許我真正想釐清的是 <code>並非把 I/O 變成 non-blocking / asynchronous 系統效能就會無腦提升</code>，memory 的 copy / interrupt handler 處理等還是會佔用 CPU 時間，可以參考另一篇 <a class=link href>cloudflare</a> 的整理，真正想做到效能提升有時還是需要 I/O 裝置的升級</p><p>研究的過程還有很多沒解釋清楚的地方，例如 File 的資料如何被 I/O 裝置讀寫，需要在涉獵更多硬體相關的知識，或許該來研究樹莓派了 XD</p><p>總之，也算是稍稍釐清困擾自己多年的疑惑，希望也可以分享給對於應用程式與 I/O 裝置互動有疑問的人，我在每一段都盡可能留下參照的 lkmpg 章節，強烈推薦有興趣可以讀完整篇，對於 Linux 作業系統有基本的認知</p><p>如果有任何不清楚或寫錯的地方，再麻煩留言指教</p></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><div class=disqus-container><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//yuanchieh.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2023 Yuanchieh</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.17.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>