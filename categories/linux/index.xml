<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on Yuanchieh</title><link>https://yuanchieh.page/categories/linux/</link><description>Recent content in Linux on Yuanchieh</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 06 Feb 2022 01:21:40 +0000</lastBuildDate><atom:link href="https://yuanchieh.page/categories/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>I/O 同步與非同步：從硬體、作業系統到應用程式</title><link>https://yuanchieh.page/posts/2022/2022-02-06-i/o-%E5%90%8C%E6%AD%A5%E8%88%87%E9%9D%9E%E5%90%8C%E6%AD%A5%E5%BE%9E%E7%A1%AC%E9%AB%94%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E5%88%B0%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F/</link><pubDate>Sun, 06 Feb 2022 01:21:40 +0000</pubDate><guid>https://yuanchieh.page/posts/2022/2022-02-06-i/o-%E5%90%8C%E6%AD%A5%E8%88%87%E9%9D%9E%E5%90%8C%E6%AD%A5%E5%BE%9E%E7%A1%AC%E9%AB%94%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E5%88%B0%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F/</guid><description>&lt;p>從應用程式的角度，執行任務可以分成 I/O bound 與 CPU bound，而 I/O 處理相比於 CPU 運算速度慢好幾個層級，所以當 I/O 還沒準備好時會「主動讓」給其他任務，盡可能地讓 CPU 保持忙碌，等到 「I/O 準備好再重新回到 CPU 執行」&lt;/p>
&lt;p>在之前理解 Nodejs non-blocking I/O 時，官方文件 &lt;a class="link" href="https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/" target="_blank" rel="noopener"
>Overview of Blocking vs Non-Blocking&lt;/a> 寫到&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">Any code that is expected to run in a concurrent manner must allow the event loop to &lt;span class="k">continue&lt;/span> running as non-JavaScript operations, like I/O, are occurring.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Nodejs sdk 有提供 non-blocking I/O 機制，底層 libuv 會處理 event loop 與其餘 I/O 的執行，「當 I/O 執行時可以讓其他的 JavaScript code 繼續運行不被 block」&lt;/p>
&lt;p>所有用「」括起來的地方都是我所想不透的，為什麼 I/O 運行時其他 JavaScript Code 可以繼續運行？是因為 Nodejs 有某種特殊的方法知道目前的程式在等待 I/O 所以主動切換不同的任務執行？如果不是 Nodejs runtime 切換，那會是作業系統切換的嗎？該怎麼切換？&lt;br>
又為什麼 I/O 的處理不需要 CPU 的介入嗎？ CPU 怎麼知道 IO 處理完了該繼續往下執行？是不是我的 IO 全部改成 asynchronous 效能就突飛猛進？那為什麼 async io 並不是每個程式語言執行時的預設支援？&lt;/p>
&lt;p>同樣最近在看 Golang goroutine &lt;a class="link" href="https://medium.com/a-journey-with-go/go-goroutine-os-thread-and-cpu-management-2f5a5eaf518a" target="_blank" rel="noopener"
>Go: Goroutine, OS Thread and CPU Management&lt;/a>時又遇到相同的問題，當讀到 goroutine 等待 I/O 回應時 M 會解除 P 並進入等待，讓其他的 M 執行；如果是遇到 network 相關的 I/O 則推至 network poll 等待 network 完成&lt;/p>
&lt;p>從應用程式開發者的角度，我們只要知道有&lt;code>神秘的小精靈&lt;/code>會幫我們完成 I/O，JavaScript callback / goroutine system call 可以在非同步的狀況下拿到 I/O 回傳的結果就好&lt;/p>
&lt;blockquote>
&lt;p>但往下思索，這一切的黑幕背後有滿山滿谷的疑惑&lt;/p>
&lt;/blockquote>
&lt;h2 id="作業系統與-io-裝置">作業系統與 I/O 裝置&lt;/h2>
&lt;p>為了讓開發者可以專注於軟體開發，應用程式多半運行在作業系統之上，透過作業系統提供的統一介面抽象化硬體，並確保單一應用程式不會霸佔硬體資源，所有與 I/O 裝置設備通訊都必須經過作業系統的操控 system call，而這神秘的小精靈就躲在這個環節中&lt;/p>
&lt;p>從 high level 的角度來看，大致如下
&lt;img src="https://yuanchieh.page/post/2022/img/0206/io.png"
loading="lazy"
>
分成兩條路線：應用程式主動呼叫與 I/O 裝置主動觸發&lt;/p>
&lt;ol>
&lt;li>應用程式呼叫 system call，此時送出 interrupt 切換到 kernel space 執行&lt;/li>
&lt;li>system call 操作(如讀寫) I/O 裝置對應的 File，觸發 kernel module 運作，這邊專指 device driver 的部分&lt;/li>
&lt;li>當 I/O 裝置完成特定動作，如網卡接收到封包 / 硬碟讀取完資料，會直接透過&lt;code>硬體打出 interrupt 訊號給 CPU&lt;/code>&lt;/li>
&lt;li>CPU 會找到 OS 註冊對應的 &lt;code>interrupt handler 處理&lt;/code>，類似於 API server 註冊 api route 等 request 近來就到對應的 handler，mapping 過程稱為 &lt;code>ISR&lt;/code>&lt;/li>
&lt;li>ISR 會找到對應的 device driver 處理&lt;/li>
&lt;li>補充：這邊我們只探討跟 I/O 相關的議題，所以 interrupt handler 指的是就是以 kernel module 存在的 I/O device driver，其他還有如 timer interrupt handler 等&lt;/li>
&lt;/ol>
&lt;p>所以真正有趣的地方在於&lt;/p>
&lt;blockquote>
&lt;p>I/O device driver 如何在準備資料的時候釋放 CPU 資源，並在資料準備完成後透過 interrupt 重新向 OS 排程並回傳資料&lt;/p>
&lt;/blockquote>
&lt;p>以下將以 Linux 為主，探索作業系統與 I/O 裝置的互動&lt;/p>
&lt;h2 id="linux-kernel-module-實作">Linux Kernel module 實作&lt;/h2>
&lt;p>參考內容 &lt;a class="link" href="https://sysprog21.github.io/lkmpg/#introduction" target="_blank" rel="noopener"
>The Linux Kernel Module Programming Guide&lt;/a>，現在學習 Linux 真的很幸運有 Jserv 大大的貢獻，用影片與共筆分享在成大教授的課程，並維護這份易讀好懂的 Linux Kernel 開發教學，以下將先以實作切入&lt;/p>
&lt;h3 id="kernel-spaceuser-space-與-kernel-module">kernel space、user space 與 kernel module&lt;/h3>
&lt;p>先前提到作業系統是為了統一管理硬體而存在，避免應用程式霸佔資源而使其他應用程式無法使用，在執行層面 Linux 拆成 kernel space 與 user space，kernel space 可以操作所以的資源，而一般應用程式執行於 user space 當中，這樣的保護是基於 &lt;code>CPU 所提供&lt;/code>，CPU 有不同的模式可以用型，kernel space 有最高權限 (supervisor mode) 而 user space 則是最低權限 (protect mode)&lt;/p>
&lt;p>kernel module 是在 &lt;code>Linux runtime 可以動態開關而不需要重新編譯 kernel image 的一段程式&lt;/code>，可直接在 kernel space 執行，常見為 I/O device driver&lt;/p>
&lt;p>又因為 kernel module 是屬於 kernel 的一部分，所以他們的資源是共享的如記憶體，同樣的如果 &lt;code>kernel module 有問題連帶整個 kernel 都會 crash&lt;/code>，以下實驗建議另外開 VM 嘗試，我自己是用 Macbook M1 + Ubuntu 20.20 VM 執行&lt;/p>
&lt;h3 id="hello-world---kernel-module">hello world - kernel module&lt;/h3>
&lt;p>參考資料 &lt;a class="link" href="https://sysprog21.github.io/lkmpg/#hello-and-goodbye" target="_blank" rel="noopener"
>lkmpg - 4.2 Hello and Goodbye&lt;/a>&lt;br>
讓我們先從最簡單的 hello world 開始，先了解最基本的 kernel module 安裝、卸載與執行過程&lt;/p>
&lt;h4 id="1-hello-world">1. hello world&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * hello-1.c - The simplest kernel module.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;linux/kernel.h&amp;gt; /* Needed for pr_info() */ &lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;linux/module.h&amp;gt; /* Needed by all modules */ &lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">init_module&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">pr_info&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello world 1.&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/* A non 0 return means init_module failed; module can&amp;#39;t be loaded. */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">cleanup_module&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">pr_info&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Goodbye world 1.&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">MODULE_LICENSE&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;GPL&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>編寫 kernel module 時，有以下三點必備&lt;/p>
&lt;ol>
&lt;li>當 module 安裝時要做什麼：init_module&lt;/li>
&lt;li>當 module 移除時要做什麼：cleanup_module&lt;/li>
&lt;li>指定 module 的 license：MODULE_LICENSE&lt;/li>
&lt;/ol>
&lt;p>需要注意的是，這個 program 在輸出時是用 pr_info 而非 printf，原因是參考 &lt;a class="link" href="https://www.calleluks.com/the-four-stages-of-compiling-a-c-program/" target="_blank" rel="noopener"
>C 編譯過程&lt;/a> 在第三階段 Assembly 產出 object code，如果有外部函式庫呼叫會在第四 Linking 階段補上缺少的 object code；&lt;br>
但是 kernel module 的第四階段不同，他只能解析 kernel 所註冊的 symbol，也就是 kernel 本身提供的 system call，可以在 &lt;code>/proc/kallsyms&lt;/code> 查看&lt;/p>
&lt;h4 id="2-條列--安裝--移除-kernel-module">2. 條列 / 安裝 / 移除 kernel module&lt;/h4>
&lt;p>編譯用的 MakeFile 參考上附連結，產出 module object code 後，可以透過以下指令操作 kernel module&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">// 條列
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo lsmod
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// 安裝
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo insmod &lt;span class="o">{&lt;/span>module.ko&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">// 移除
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ sudo rmmode &lt;span class="o">{&lt;/span>module&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以透過 &lt;code>$ sudo journalctl --since &amp;quot;1 hour ago&amp;quot; | grep kernel&lt;/code> 查看近一小時 kernel module 打印結果&lt;/p>
&lt;h3 id="device-driver">device driver&lt;/h3>
&lt;p>&lt;code>所有的裝置在 linux 中都是 file&lt;/code>，資料結構可以參考 &lt;a class="link" href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fs.h" target="_blank" rel="noopener"
>include/linux/fs.h&lt;/a>，首先要先釐清這邊的 File &lt;code>只存在於 kernel&lt;/code>，雖然中文可能都被翻成文件或檔案，但實際上與檔案系統中的檔案概念是不同的! 後者通常是叫做 &lt;strong>inode&lt;/strong>&lt;/p>
&lt;p>所以每一個裝置在 linux 中都是以一個 file 存在，通常儲存於 &lt;code>/dev/&lt;/code> 底下，而 device driver 則是 user space 應用程式與 device 溝通的管道，流程大致是&lt;/p>
&lt;ol>
&lt;li>driver 向 kernel 註冊取得屬於自己的裝置編號與指定檔案&lt;/li>
&lt;li>driver 定義檔案操作&lt;/li>
&lt;/ol>
&lt;h4 id="1-註冊裝置">1. 註冊裝置&lt;/h4>
&lt;p>參考資料 &lt;a class="link" href="https://sysprog21.github.io/lkmpg/#device-drivers" target="_blank" rel="noopener"
>lkmpg - 5.6 Device Drivers&lt;/a>
先觀察系統中既有的裝置&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ ls -l /dev/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看到類似的輸出&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">brw-rw---- &lt;span class="m">1&lt;/span> root disk 3, &lt;span class="m">1&lt;/span> Jul &lt;span class="m">5&lt;/span> &lt;span class="m">2000&lt;/span> /dev/hda1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">brw-rw---- &lt;span class="m">1&lt;/span> root disk 3, &lt;span class="m">2&lt;/span> Jul &lt;span class="m">5&lt;/span> &lt;span class="m">2000&lt;/span> /dev/hda2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">brw-rw---- &lt;span class="m">1&lt;/span> root disk 3, &lt;span class="m">3&lt;/span> Jul &lt;span class="m">5&lt;/span> &lt;span class="m">2000&lt;/span> /dev/hda3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意到 &amp;ldquo;3, 1&amp;rdquo; 這類型的字串，前面是 major number 後面是 minor number，分別代表 &lt;code>指定 driver, 裝置 id&lt;/code>，每個 device driver 都會被分配一個 id，而可能有多個裝置都是由同一個 driver 所驅動，所以有第二個 minor id 讓 driver 區分不同的硬體&lt;/p>
&lt;p>接著注意到最前的字元，可能會看到 &lt;code>d / b / c&lt;/code> 三種，d 代表 directory 目錄，b 代表 block、c 代表 char；&lt;br>
block device 是指說操作會以 block 為單位，所以有時操作會被 buffer 後才執行，例如硬碟儲存裝置，可以最佳化讀寫的效率；&lt;br>
char device 則沒有 buffer，可以任意讀寫不同的大小，幾乎大多數的裝置都是 char device&lt;/p>
&lt;h4 id="2-註冊檔案操作">2. 註冊檔案操作&lt;/h4>
&lt;p>當我們想指定 device driver 如何操作檔案時，會定義 file_operations，指定當檔案被讀取 / 寫入時要對應觸發的 handler function，可以看到以下 struct 中幾乎都是定義 &lt;a class="link" href="https://chenhh.gitbooks.io/parallel_processing/content/cython/function_pointer.html" target="_blank" rel="noopener"
>function pointer&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">file_operations&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="n">module&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">owner&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">loff_t&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">llseek&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">loff_t&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">ssize_t&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">read&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">__user&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">size_t&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">loff_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">ssize_t&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">write&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">__user&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">size_t&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">loff_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">ssize_t&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">read_iter&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">kiocb&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">iov_iter&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">ssize_t&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">write_iter&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">kiocb&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">iov_iter&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.....&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>補充 file 相關資料 &lt;a class="link" href="https://blog.jaycetyle.com/2018/12/linux-fd-open-close/" target="_blank" rel="noopener"
>Linux 系統程式設計 - fd 及 open()、close() 系統呼叫&lt;/a>，file 在 Linux 中必須先被 open() 才能執行後續的讀寫操作，open() 時會把檔案稱作 &lt;code>open file&lt;/code>，此時會回傳 &lt;code>file descriptor&lt;/code>，資料結構就是上面的 file_operations 紀錄每種動作對應的處理方法&lt;/p>
&lt;h4 id="3-範例程式碼">3. 範例程式碼&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;span class="lnt">54
&lt;/span>&lt;span class="lnt">55
&lt;/span>&lt;span class="lnt">56
&lt;/span>&lt;span class="lnt">57
&lt;/span>&lt;span class="lnt">58
&lt;/span>&lt;span class="lnt">59
&lt;/span>&lt;span class="lnt">60
&lt;/span>&lt;span class="lnt">61
&lt;/span>&lt;span class="lnt">62
&lt;/span>&lt;span class="lnt">63
&lt;/span>&lt;span class="lnt">64
&lt;/span>&lt;span class="lnt">65
&lt;/span>&lt;span class="lnt">66
&lt;/span>&lt;span class="lnt">67
&lt;/span>&lt;span class="lnt">68
&lt;/span>&lt;span class="lnt">69
&lt;/span>&lt;span class="lnt">70
&lt;/span>&lt;span class="lnt">71
&lt;/span>&lt;span class="lnt">72
&lt;/span>&lt;span class="lnt">73
&lt;/span>&lt;span class="lnt">74
&lt;/span>&lt;span class="lnt">75
&lt;/span>&lt;span class="lnt">76
&lt;/span>&lt;span class="lnt">77
&lt;/span>&lt;span class="lnt">78
&lt;/span>&lt;span class="lnt">79
&lt;/span>&lt;span class="lnt">80
&lt;/span>&lt;span class="lnt">81
&lt;/span>&lt;span class="lnt">82
&lt;/span>&lt;span class="lnt">83
&lt;/span>&lt;span class="lnt">84
&lt;/span>&lt;span class="lnt">85
&lt;/span>&lt;span class="lnt">86
&lt;/span>&lt;span class="lnt">87
&lt;/span>&lt;span class="lnt">88
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">static&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">file_operations&lt;/span> &lt;span class="n">chardev_fops&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span>&lt;span class="n">read&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">device_read&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span>&lt;span class="n">write&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">device_write&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span>&lt;span class="n">open&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">device_open&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span>&lt;span class="n">release&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">device_release&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">__init&lt;/span> &lt;span class="nf">chardev_init&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">major&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">register_chrdev&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">DEVICE_NAME&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">chardev_fops&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">major&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">pr_alert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Registering char device failed with %d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">major&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">major&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">pr_info&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;I was assigned major number %d.&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">major&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cls&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">class_create&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">THIS_MODULE&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">DEVICE_NAME&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">device_create&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">cls&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nf">MKDEV&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">major&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">DEVICE_NAME&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">pr_info&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Device created on /dev/%s&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">DEVICE_NAME&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">SUCCESS&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/* Methods */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/* Called when a process tries to open the device file, like
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * &amp;#34;sudo cat /dev/chardev&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">device_open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">inode&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">static&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">counter&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">atomic_cmpxchg&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">already_open&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">CDEV_NOT_USED&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">CDEV_EXCLUSIVE_OPEN&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">EBUSY&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">sprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">msg&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;I already told you %d times Hello world!&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">counter&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">try_module_get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">THIS_MODULE&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">SUCCESS&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/* This function is called whenever a process which has already opened the
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * device file attempts to read from it.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">static&lt;/span> &lt;span class="kt">ssize_t&lt;/span> &lt;span class="nf">device_read&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">struct&lt;/span> &lt;span class="n">file&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="cm">/* see include/linux/fs.h */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">char&lt;/span> &lt;span class="n">__user&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">buffer&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="cm">/* buffer to be filled */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">size_t&lt;/span> &lt;span class="n">length&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="cm">/* length of the buffer */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">loff_t&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">offset&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/* Number of bytes actually written to the buffer */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">bytes_read&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/* How far did the process reading the message get? Useful if the message
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * is larger than the size of the buffer we get to fill in device_read.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">message_ptr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">message&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">message_ptr&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">offset&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="cm">/* we are at the end of message */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">*&lt;/span>&lt;span class="n">offset&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* reset the offset */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* signify end of file */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">message_ptr&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">offset&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/* Actually put the data into the buffer */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">length&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">message_ptr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/* Because the buffer is in the user data segment, not the kernel
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * data segment, assignment would not work. Instead, we have to
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * use put_user which copies data from the kernel data segment to
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * the user data segment.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">put_user&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">message_ptr&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">buffer&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">length&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">bytes_read&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">pr_info&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Read %d bytes, %ld left&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">bytes_read&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">length&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">*&lt;/span>&lt;span class="n">offset&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">bytes_read&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/* Read functions are supposed to return the number of bytes actually
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * inserted into the buffer.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">bytes_read&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>結論關鍵的程式碼&lt;/p>
&lt;ol>
&lt;li>透過 register_chrdev 註冊裝置與指定的 file，系統會返回 major number&lt;/li>
&lt;li>註冊 file_operators，可以挑選需要的 handler 註冊&lt;/li>
&lt;li>可以注意一下 device_read 註解，裡面有個 system call &lt;code>put_user&lt;/code>，因為 driver 是在 kernel mode，而 read 是從 user space 觸發，當今天 driver 想要回傳資料給 user space，不能直接寫入記憶體，而是需要透過 put_user 將記憶體從 kernel space 複製到 user space&lt;/li>
&lt;/ol>
&lt;p>執行上的細節就不贅述，有興趣可以看參考資料&lt;/p>
&lt;h4 id="io-blocking--non-blocking">IO blocking / non-blocking&lt;/h4>
&lt;p>參考資料 &lt;a class="link" href="https://sysprog21.github.io/lkmpg/#blocking-processes-and-threads" target="_blank" rel="noopener"
>lkmpg - 11 Blocking Processes and threads&lt;/a>&lt;/p>
&lt;p>當應用程式決定操作 I/O 時，device driver 可能面臨資料尚未準備好的情況，此時會透過 &lt;code>O_NONBLOCK&lt;/code> flag 決定是否為 block 應用程式，如果 non-blocking 則直接回傳錯誤 &lt;code>-O_NONBLOCK&lt;/code> 讓應用程式晚點重試 (polling)，這也就是 Nodejs 所透過的方式，non-blocking I/O (這句話不全然對，還是要看 libuv 針對不同 I/O 的實作，但 non-blocking 就是指這種情況沒錯)&lt;/p>
&lt;p>或是應用程式選擇 block mode，此時 device driver 還在等待資料的同時，可以選擇透過 &lt;code>wait_event_interruptible&lt;/code> 主動交出 CPU 控制權，避免無謂的佔用 CPU 資源；
同時在 wait 之前會先註冊對應的 &lt;code>wake_up&lt;/code> 事件，或是收到 signal 會再叫醒原本沈睡的 process&lt;/p>
&lt;p>&lt;img src="https://yuanchieh.page/post/2022/img/0206/blocking.png"
loading="lazy"
>&lt;br>
*圖片參考資料 &lt;a class="link" href="https://medium.com/@clu1022/%E6%B7%BA%E8%AB%87i-o-model-32da09c619e6" target="_blank" rel="noopener"
>https://medium.com/@clu1022/%E6%B7%BA%E8%AB%87i-o-model-32da09c619e6&lt;/a>&lt;/p>
&lt;p>重新回來看 blocking 與 non-blocking 的圖，這邊是從應用程式角度出發，blocking I/O 會在 kernel device driver 沒有資料時等待，但從 kernel 角度，如果有指定 interruptable 則作業系統會切換到不同的 process 去，所以也不會有資源浪費的問題 (撇除 context switching 開銷)&lt;/p>
&lt;h3 id="system-call">system call&lt;/h3>
&lt;p>參考資料 &lt;a class="link" href="https://sysprog21.github.io/lkmpg/#system-calls" target="_blank" rel="noopener"
>lkmpg - 10. system call&lt;/a>&lt;/p>
&lt;p>前面實作了簡單的 kernel module，並看到 device driver 可以在 file 發生變化時產生對應的行為，但一般來說應用程式與 kernel 的互動是透過封裝過後的 system call&lt;/p>
&lt;p>Linux kernel 會有一張 table &lt;code>sys_call_table&lt;/code> 儲存支援的 system call 與對應的 address， 當應用程式需要操作硬體需要指定 system call，例如 open() 開啟檔案 / read() 讀取檔案等，在暫存器寫入指定資料後透過特殊指令 interrupt 通知 CPU 要切換 kernel space 執行 (在 intel 中是 0x80)，進階資料可以參考 &lt;a class="link" href="https://en.wikipedia.org/wiki/Protection_ring" target="_blank" rel="noopener"
>CPU protection ring&lt;/a>&lt;/p>
&lt;h4 id="1-從-printf-觀察-system-call">1. 從 printf 觀察 system call&lt;/h4>
&lt;p>參考 &lt;a class="link" href="https://sysprog21.github.io/lkmpg/#functions-available-to-modules" target="_blank" rel="noopener"
>lkmpg 5.2 Functions available to modules&lt;/a>
透過最簡單的 c program printf 來看 system call 的執行&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stdio.h&amp;gt; &lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;hello&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>打包後透過 &lt;a class="link" href="https://strace.io/" target="_blank" rel="noopener"
>strace&lt;/a> 查看 system call 狀況&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ gcc -Wall -o hello hello.c
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ strace ./hello.o
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>打印出蠻多東西，包含一些 memory allocate 的指令等，最終可以看到 &lt;code>write&lt;/code> 的 system call 呼叫&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">write&lt;span class="o">(&lt;/span>1, &lt;span class="s2">&amp;#34;hello world&amp;#34;&lt;/span>, 11hello world&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">exit_group&lt;span class="o">(&lt;/span>0&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="2-修改-system-call">2. 修改 system call&lt;/h4>
&lt;p>如果我們希望修改 system call，理論上可以直接改 sys_call_table 的 mapping，但基於安全性考量這是無法直接在 runtime 操作的，原因是避免 hacker 直接修改 system call&lt;/p>
&lt;p>第二個嘗試可以透過 &lt;code>$sudo grep sys_call_table /proc/kallsyms&lt;/code> 找出 sys_call_table 所儲存的實際記憶體位置並替換，但這目前也不行，同樣是因為安全性考量， Linux kernel 在每次 boot 時會動態擾亂 kernel code 跟 data (稱為 KASLR)，增加 hacker 嘗試攻擊的難度&lt;/p>
&lt;p>一個可行的做法是透過 &lt;a class="link" href="https://ztex.medium.com/kprobe-%E7%AD%86%E8%A8%98-59d4bdb1e1fe" target="_blank" rel="noopener"
>kprobe&lt;/a>，這是一個 kernel debug 的工具，當 CPU 執行到中斷點時會保存暫存器狀態，並執行 kprobe 指定的指令，可以透過這種方式去動態調整 system call 執行&lt;/p>
&lt;p>但上面的方法在 production 很危險，試想如果有多個 kernel module 去調整 system call，在 restore 時可能會發生意外，不論是復原錯誤或是執行到已經移除的 kernel module，所以建議是直接重新編譯 kernel&lt;/p>
&lt;h2 id="cpu-與-hardware-interrupt">CPU 與 Hardware interrupt&lt;/h2>
&lt;p>上面大致描述綠線的走向，從 user space 呼叫 system call，觸發對應 device driver 所指定的 file operation&lt;/p>
&lt;p>接下來看藍線的部分，當 I/O device 收到外部訊號如網卡收到封包、鍵盤被按下按鈕，如何送出中斷給 CPU 並進入後續的處理&lt;/p>
&lt;p>具體內容請參考宅色夫的 &lt;a class="link" href="https://hackmd.io/@sysprog/linux-interrupt" target="_blank" rel="noopener"
>Linux 核心設計: 中斷處理和現代架構考量&lt;/a>，這邊僅大致提一下流程&lt;/p>
&lt;ol>
&lt;li>I/O 裝置送出 Interrupt Request (IRQ)&lt;/li>
&lt;li>Hardware controller 整理後送出 interrupt vector 到 CPU&lt;/li>
&lt;li>CPU 切換模式立即處理 interrupt，透過 ISR 找到對應的 Interrupt Handler&lt;/li>
&lt;li>Interrupt handler 中有分成 top half / bottom half，top half 是不會被其他 Interrupt 中斷，所以一定會當下完成；而 bottom half 則會被排入 softiqr 重新排成，&lt;code>soft&lt;/code> 在 OS 中有時是代表不確定何時會被完成&lt;/li>
&lt;/ol>
&lt;p>實作面的部分參考 &lt;a class="link" href="https://sysprog21.github.io/lkmpg/#detecting-button-presses" target="_blank" rel="noopener"
>lkmpg 15.2 Detecting button presses&lt;/a>，透過 &lt;code>request_irq&lt;/code> 註冊 interrupt request，當指定的 I/O 發生 interrupt 時就會呼叫註冊的 funtion&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">ret&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">request_irq&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">button_irqs&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">button_isr&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">IRQF_TRIGGER_RISING&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="n">IRQF_TRIGGER_FALLING&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;gpiomod#button1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">NULL&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>更多的討論可以參考文件，不同的 CPU 與作業系統有不同的考量，考慮到排程 realtime OS 的設計又會有不同&lt;/p>
&lt;h2 id="延伸linux-的-asynchronous-io">延伸：Linux 的 Asynchronous I/O&lt;/h2>
&lt;p>現在流行的 network I/O 處理方式是透過 I/O multiplexing，如 Linux 的 epoll，而 asynchrous I/O 看起來十分的迷人，應用程式發出請求後就直接等到作業系統通知，中間完全不用等待，但為什麼目前沒有被大規模採納呢？&lt;/p>
&lt;p>&lt;img src="https://yuanchieh.page/post/2022/img/0206/io2.png"
loading="lazy"
>&lt;br>
*圖片參考資料 &lt;a class="link" href="https://medium.com/@clu1022/%E6%B7%BA%E8%AB%87i-o-model-32da09c619e6" target="_blank" rel="noopener"
>https://medium.com/@clu1022/%E6%B7%BA%E8%AB%87i-o-model-32da09c619e6&lt;/a>&lt;/p>
&lt;p>參考資料 &lt;a class="link" href="https://kernel.dk/io_uring.pdf" target="_blank" rel="noopener"
>Efficient IO with io_uring&lt;/a>，AIO 在 Linux 2.5 就已經加入了，但持續被詬病例如針對 buffer i/o 還是會變成 synchronous 且 API 難以使用，在 Linux 5.1 後加入了 &lt;code>io_urning&lt;/code>新的 AIO API 並持續優化&lt;/p>
&lt;p>libuv 有開始討論導入 io_uring 的部分，有人提供 &lt;a class="link" href="https://github.com/libuv/libuv/issues/1947#issuecomment-485230126" target="_blank" rel="noopener"
>benchmark&lt;/a> 在讀取檔案部分可以比原本的 thread pool 設計更快&lt;/p>
&lt;p>&lt;a class="link" href="https://stackoverflow.com/questions/13407542/is-there-really-no-asynchronous-block-i-o-on-linux" target="_blank" rel="noopener"
>SO: Is there really no asynchronous block I/O on Linux?&lt;/a> 裡面有提供很多的相關連結，資料庫如 PostgreSQL / RocksDB 嘗試用 io_uring 提升硬碟讀寫效能，在 networking 方面也有一些嘗試，在另一篇文章 &lt;a class="link" href="https://hackmd.io/@shanvia/B1Ds1vlAD" target="_blank" rel="noopener"
>Epoll vs. io_uring 效能測試與比較&lt;/a>看起來效能提升不少，CPU 使用率低且能處理更多的 request，之後有機會再深入研究&lt;/p>
&lt;h2 id="總結">總結&lt;/h2>
&lt;p>突然間不知如何總結，研究的過程比想像中發散，看了很多文件 XD&lt;/p>
&lt;p>大抵上從 high level 角度理解了整個 I/O 發生的過程，認識到了「應用程式讀寫 IO 的過程」，中間涉及到 system call / kernel module 的執行，以及 OS context switch 的過程，或許我真正想釐清的是 &lt;code>並非把 I/O 變成 non-blocking / asynchronous 系統效能就會無腦提升&lt;/code>，memory 的 copy / interrupt handler 處理等還是會佔用 CPU 時間，可以參考另一篇 &lt;a class="link" href="" >cloudflare&lt;/a> 的整理，真正想做到效能提升有時還是需要 I/O 裝置的升級&lt;/p>
&lt;p>研究的過程還有很多沒解釋清楚的地方，例如 File 的資料如何被 I/O 裝置讀寫，需要在涉獵更多硬體相關的知識，或許該來研究樹莓派了 XD&lt;/p>
&lt;p>總之，也算是稍稍釐清困擾自己多年的疑惑，希望也可以分享給對於應用程式與 I/O 裝置互動有疑問的人，我在每一段都盡可能留下參照的 lkmpg 章節，強烈推薦有興趣可以讀完整篇，對於 Linux 作業系統有基本的認知&lt;/p>
&lt;p>如果有任何不清楚或寫錯的地方，再麻煩留言指教&lt;/p></description></item></channel></rss>